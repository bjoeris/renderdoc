#include "cpp_codec_resource.h"
namespace cpp_codec
{
namespace
{
const char fileData_1[] =
  "{{define \"CPP.Type\"}}\n  {{if Or (IsSDString $) (And (IsSDArray $) (Eq (Type $) \"string\"))}}const char *{{S}}\n  {{el"
  "se}}{{Type $}} {{S}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.Value.Default\"}}\n  {{     if Not (IsSDObject $)}}{{$}}{{S}}\n"
  "  {{else if IsSDResource $}}\n    {{if $ | ToUInt | Eq 0}}\n      NULL{{S}}\n    {{else}}\n      {{if IsSDPointer $}}&{{S"
  "}}{{end}}\n      {{/* {{GlobalVar $}}{{S}} */}}\n      {{template \"CPP.GlobalVariable\" $}}\n    {{end}}\n  {{else if Ha"
  "sCustomString $}}{{$}}{{S}}\n  {{else if IsSDNull $}}NULL{{S}}\n  {{else if IsSDString $}}\"{{Escape $}}\"{{S}}\n  {{else"
  " if IsSDUInt64 $}}{{$}}ull{{S}}\n  {{else if IsSDInt64 $}}{{$}}ll{{S}}\n  {{else if IsSDUInt $}}{{$}}u{{S}}\n  {{else if "
  "IsSDFloat32 $}}{{$}}f{{S}}\n  {{else if IsSDBuffer $}}{{BufferVar $}}.data(){{S}}\n  {{else if IsSDStruct $}}{{template \""
  "CPP.InlineStruct\" Dict \"name\" (Name $) \"obj\" $}}\n  {{else}}{{$}}{{S}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.Value\""
  "}}\n  {{template \"CPP.Value.Default\"}}\n{{end}}\n\n{{define \"CPP.GlobalVariable.Type\"}}\n  {{if IsSDObject $}}\n    {"
  "{Type $}}{{S}}\n  {{else if $.type}}\n    {{$.type}}{{S}}\n  {{else if IsSDObject $.id}}\n    {{Type $.id}}{{S}}\n  {{els"
  "e}}\n    {{Error \"Invalid arguments\"}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.GlobalVariable.Name\"}}\n  {{if IsSDObject"
  " $}}\n    {{template \"CPP.GlobalVariable.Type\"}}_{{ToUInt $}}{{S}}\n  {{else}}\n    {{$name := $.name}}\n    {{if Not $"
  "name}}\n      {{$name = $.type}}\n      {{if Not $name}}\n        {{$name = Macro \"CPP.GlobalVariable.Type\"}}\n      {{"
  "end}}\n    {{end}}\n    {{if $.id}}\n      {{$name = Print $name \"_\" (ToUInt $.id)}}\n    {{end}}\n    {{$name}}{{S}}\n"
  "  {{end}}\n{{end}}\n\n{{define \"CPP.GlobalVariable.h\"}}\n  extern {{$.type}} {{$.name}};\n{{end}}\n\n{{define \"CPP.Glo"
  "balVariable.cpp\"}}\n  {{$.type}} {{$.name}}{{S}}\n  {{if $.value}}\n    = {{template \"CPP.Value\" $.value}}{{S}}\n  {{e"
  "nd}}\n  ;\n{{end}}\n\n{{define \"CPP.GlobalVariable\"}}\n  {{$name := Macro \"CPP.GlobalVariable.Name\"}}\n  {{$type := M"
  "acro \"CPP.GlobalVariable.Type\"}}\n  {{$unpacked := Dict \"name\" $name \"type\" $type \"value\" $.value}}\n  {{if Regis"
  "terGlobalVar $name}}\n    {{ExecTemplate \"variables.h\" \"CPP.GlobalVariable.h\" $unpacked}}\n    {{ExecTemplate \"varia"
  "bles.cpp\" \"CPP.GlobalVariable.cpp\" $unpacked}}\n  {{end}}\n  {{$name}}{{S}}\n{{end}}\n\n{{define \"CPP.InlineStruct\"}"
  "}\n  {{$children := $.obj | RemoveHidden | RemoveDuplicates}}\n  {{if And (IsSDNull $.obj) ($children | Size | Eq 0)}}\n "
  "   NULL{{S}}\n  {{else}}\n    {\n      {{$name := Print $.name $.suffix}}\n      {{$path := $.path}}\n      {{if Not $pat"
  "h}}\n        {{$path = $name}}\n      {{end}}\n      {{range $i, $childName, $child := $children}}\n\n        {{/* If the"
  " child is a local variable, this is what it is called */}}\n        {{$childVar := Macro \"CPP.LocalVariableName\" (Dict "
  "\"name\" $childName \"obj\" $child \"suffix\" $.suffix)}}\n      \n        {{/* String used to describe the child in a co"
  "mment in the generated code */}}\n        {{/* For struct fields, this is just the field name; for arrays, this something"
  " like \"array[42]\" */}}\n        {{$childPath := $childName}}\n\n        {{/* String to generate the correct `childComme"
  "nt` in the recursive call. */}}\n        {{/* This is used so that nested arrays get `childComment`s like \"array[1][2]\""
  ". */}}\n        {{/* {{$childPath := $childComment}} */}}\n        {{if IsSDArray $.obj}}\n          {{$childVar = Print "
  "$name \"_\" $i}}\n          {{$childPath = Print $path \"[\" $i \"]\"}}\n          {{/* {{$childComment = $childPath}} */"
  "}}\n        {{end}}\n\n        /* {{$childPath}} = */ {{S}}\n        {{if And (IsSDObject $child) (Not (IsInlineable $chi"
  "ld))}}{{$childVar}},\n        {{else if And (Not (HasCustomString $child)) (Or (IsSDStruct $child) (IsSDArray $child))}}\n"
  "          {{template \"CPP.InlineStruct\" Dict \"name\" $childVar \"obj\" $child \"path\" $childPath}},\n        {{else}}"
  "{{template \"CPP.Value\" $child}},\n        {{end}}\n      {{end}}\n    }{{S}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.Loca"
  "lVariableName\"}}\n  {{if IsSDObject $}}\n    {{Name $}}{{S}}\n  {{else}}\n    {{$name := $.name}}\n    {{if Not $name}}\n"
  "      {{$name = Name $.obj}}\n    {{end}}\n    {{$name}}{{$.suffix}}{{S}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.DeclareLo"
  "calVariable\"}}\n  {{if IsSDObject $}}\n    {{$ = Dict \"obj\" $ \"name\" (Name $) \"suffix\" \"\"}}\n  {{end}}\n  {{$nam"
  "e := Macro \"CPP.LocalVariableName\" $}}\n  {{$children := $.obj | RemoveHidden | RemoveDuplicates}}\n  {{if IsSDUnion $."
  "obj}}\n    {{template \"CPP.Type\" $.obj}} {{$name}};\n    {{template \"CPP.Assign\" (Dict \"path\" $name \"obj\" $.obj)}"
  "}\n  {{else if And (Lt 0 ($children | Size)) (Or (IsSDStruct $.obj) (IsSDArray $.obj) (IsSDUnion $.obj))}}\n    {{range $"
  "i, $childName, $child := $children}}\n      {{$childSuffix := $.suffix}}\n      {{if IsSDArray $.obj}}\n        {{$childS"
  "uffix = Print $.suffix \"_\" $i}}\n        {{$childName = Name $.obj}}\n      {{end}}\n      {{if And (IsSDObject $child)"
  " (Not (IsInlineable $child))}}\n        {{template \"CPP.DeclareLocalVariable\" Dict \"name\" $childName \"obj\" $child \""
  "suffix\" $childSuffix}}\n      {{end}}\n    {{end}}\n\n    {{$type := Macro \"CPP.Type\" $.obj}}\n    {{if IsSDPointer $."
  "obj}}\n      {{$name = Print $name \"[1]\"}}\n    {{else if IsSDArray $.obj}}\n      {{$name = Print $name \"[\" (Size $."
  "obj) \"]\"}}\n    {{end}}\n    {{$type}} {{$name}} = {{template \"CPP.InlineStruct\" $}};\n  {{end}}\n{{end}}\n\n{{define"
  " \"CPP.Assign\"}}\n  {{if Or (IsSDStruct $.obj) (IsSDArray $.obj) (IsSDUnion $.obj)}}\n    {{$children := $.obj | RemoveH"
  "idden | RemoveDuplicates}}\n    {{range $i, $childName, $child := $children}}\n      {{$childPath := \"\"}}\n      {{if I"
  "sSDArray $.obj}}\n        {{$childPath = Print \"[\" $i \"]\"}}\n      {{else if IsSDPointer $.obj}}\n        {{$childPat"
  "h = Print \"->\" $childName}}\n      {{else}}\n        {{$childPath = Print \".\" $childName}}\n      {{end}}\n\n      {{"
  "/* Comment out non-canonical union branch assignments */}}\n      {{$comment := \"\"}}\n      {{if And (IsSDUnion $.obj) "
  "(Ne $i (CaninonicalUnionBranch $.obj))}}\n        {{$comment = \"// \"}}\n      {{end}}\n\n      {{PushPrefix $comment}}\n"
  "      {{template \"CPP.Assign\" Dict \"path\" (Print $.path $childPath) \"obj\" $child}}\n      {{PopPrefix}}\n    {{end}"
  "}\n  {{else}}\n    {{$.path}} = {{template \"CPP.Value\" $.obj}};\n  {{end}}\n{{end}}\n\n{{define \"CPP.DeclareArg\"}}\n "
  " {{if IsSDObject $}}\n    {{if Or (IsSDStruct $) (IsSDArray $) (Not (IsInlineable $))}}\n      {{/* Declare a local varia"
  "ble for any args that either can't be */}}\n      {{/* inlined (like pointers), or look bad when inlined */}}\n      {{/*"
  " (like non-pointer structs) */}}\n      {{template \"CPP.DeclareLocalVariable\" $}}\n    {{end}}\n  {{end}}\n{{end}}\n\n{"
  "{define \"CPP.ArgValue\"}}\n  {{     if Not (IsSDObject $)}}{{$}}{{S}}\n  {{else if Or (IsSDStruct $) (IsSDArray $) (Not "
  "(IsInlineable $))}}\n    {{$children := $ | RemoveHidden | RemoveDuplicates}}\n    {{if Or (IsSDNull $) (Eq 0 ($children "
  "| Size))}}\n      NULL{{S}}\n    {{else}}\n      {{/* This is value will have a local variable variable declared in */}}\n"
  "      {{/* \"CPP.DeclareArg\", so just return the name of that variable. */}}\n      {{template \"CPP.LocalVariableName\""
  " $}}\n    {{end}}\n  {{else}}\n    {{template \"CPP.Value\" $}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.CallFunction\"}}\n "
  " {{if IsSDObject $}}\n    {{$ = Dict \"name\" (Name $) \"args\" (RemoveHidden $)}}\n  {{end}}\n  {{if $.check}}\n    {{$."
  "check}}({{S}}\n  {{end}}\n  {{range $arg := $.args}}\n    {{template \"CPP.DeclareArg\" $arg}}\n  {{end}}\n  {{$.name}}({"
  "{S}}\n  {{range $i, $_, $arg := $.args}}\n    {{if Gt $i 0}}, {{S}}{{end}}\n    {{template \"CPP.ArgValue\" $arg}}\n  {{e"
  "nd}}\n  {{if $.check}}){{S}}\n  {{end}}\n  );\n{{end}}\n\n{{define \"CPP.DefaultChunk\"}}\n  {{template \"CPP.CallFunctio"
  "n\" $}}\n{{end}}\n\n{{define \"CPP.ChunkBody.Default\"}}\n  {{$name := Name $}}\n  {{     if Eq $name \"Driver Initialisa"
  "tion Parameters\"}}\n    {{template \"CPP.DriverInit\"}}\n  {{else if Eq $name \"List of Initial Contents Resources\"}}\n"
  "    {{template \"CPP.InitialContentsList\"}}\n  {{else if Eq $name \"Initial Contents\"}}\n    {{template \"CPP.InitialCo"
  "ntents\"}}\n  {{else if Eq $name \"Beginning of Capture\"}}\n    {{template \"CPP.CaptureBegin\"}}\n  {{else if Eq $name "
  "\"Frame Metadata\"}}\n    {{template \"CPP.CaptureScope\"}}\n  {{else if Eq $name \"End of Capture\"}}\n    {{template \""
  "CPP.CaptureEnd\"}}\n  {{else}}\n    {{template \"CPP.DefaultChunk\"}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.ChunkBody\"}}"
  "\n  {{template \"CPP.ChunkBody.Default\"}}\n{{end}}\n\n{{define \"CPP.Chunk\"}}\n  { /* {{$.chunkId}} {{Name $.chunk}} */"
  "\n    /* Chunk args:\n      {{range $i, $argName, $arg := $.chunk}}\n        {{$i}} {{$argName}}\n      {{end}}\n    */\n"
  "    {{template \"CPP.ChunkBody\" $.chunk}}\n  }\n{{end}}\n\n{{define \"CPP.IfDefPlatform\"}}\n  {{if $.win32}}\n    #ifde"
  "f _WIN32\n    {{$.win32}}\n    #endif\n  {{end}}\n{{end}}\n\n{{define \"CPP.PhaseMain\"}}\n  void main_{{$.phase}}() {\n "
  "   {{range $i := Range $.count}}\n      {{$.phase}}_{{$i}}();\n    {{end}}\n  }\n{{end}}";
const char fileData_2[] =
  "{{define \"CPP.Value\"}}\n  {{if And (IsSDEnum $) (HasCustomString $) (Type $ | EndsWith \"Flags\")}}\n    {{$i := $ | Fi"
  "ndSubstring \"(\"}}\n    {{$j := $ | FindSubstring \")\"}}\n    {{if Le 0 $i $j}}\n      {{$ | Substring (Add $i 1) (Subt"
  "ract $j $i 1)}}{{S}}\n    {{else}}\n      {{template \"CPP.Value.Default\"}}\n    {{end}}\n  {{else if And (IsSDBuffer $)"
  " (Eq (Name $) \"pCode\")}}\n    (const uint32_t*){{BufferVar $}}.data(){{S}}\n  {{else}}\n    {{template \"CPP.Value.Defa"
  "ult\"}}\n  {{end}}\n{{end}}\n\n{{define \"Vulkan.InstanceVar\"}}\n  {{template \"CPP.GlobalVariable\" (GetGlobal \"VkInst"
  "ance\")}}\n{{end}}\n\n{{define \"Vulkan.PhysicalDeviceVar\"}}\n  {{template \"CPP.GlobalVariable\" (GetGlobal \"VkPhysica"
  "lDevice\")}}\n{{end}}\n\n{{define \"Vulkan.QueueFamilyPropertiesVar\"}}\n  {{template \"CPP.GlobalVariable\" (Dict \"type"
  "\" \"std::vector<VkQueueFamilyProperties>\" \"name\" \"QueueFamilyProperties\" \"id\" (GetGlobal \"VkPhysicalDevice\"))}}"
  "\n{{end}}\n\n{{define \"Vulkan.vkEnumeratePhysicalDevices.early\"}}\n  { /* vkEnumeratePhysicalDevices */\n  uint32_t phy"
  "sicalDeviceCount = 0u;\n  {{$instance := Macro \"Vulkan.InstanceVar\"}}\n  {{SetGlobal \"VkPhysicalDevice\" $.PhysicalDev"
  "ice}}\n  {{$physicalDevice := Macro \"Vulkan.PhysicalDeviceVar\"}}\n  {{$physicalDeviceProps := Macro \"CPP.GlobalVariabl"
  "e\" (Dict \"type\" \"VkPhysicalDeviceProperties\" \"id\" $.PhysicalDevice)}}\n  {{$memoryProps := Macro \"CPP.GlobalVaria"
  "ble\" (Dict \"type\" \"VkPhysicalDeviceMemoryProperties\" \"id\" $.PhysicalDevice)}}\n  {{$memoryPropsCap := Macro \"CPP."
  "GlobalVariable\" (Dict \"type\" \"VkPhysicalDeviceMemoryProperties\" \"name\" \"VkPhysicalDeviceMemoryProperties_captured"
  "\" \"id\" $.PhysicalDevice)}}\n  {{$physicalDeviceFeatures := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"VkPhysicalDev"
  "iceFeatures\" \"id\" $.PhysicalDevice)}}\n  {{$queueProps := Macro \"Vulkan.QueueFamilyPropertiesVar\"}}\n  CHECK_VK_SUCC"
  "ESS(vkEnumeratePhysicalDevices({{$instance}}, &physicalDeviceCount, NULL));\n  CHECK(physicalDeviceCount > 0u);\n  std::v"
  "ector<VkPhysicalDevice> physicalDevices((size_t)physicalDeviceCount);\n  CHECK_VK_SUCCESS(vkEnumeratePhysicalDevices({{$i"
  "nstance}}, &physicalDeviceCount, physicalDevices.data()));\n\n  {{if Lt 0 $.PhysicalDeviceIndex}}\n    if(physicalDevices"
  ".size() > {{$.PhysicalDeviceIndex}})\n      {{$physicalDevice}} = physicalDevices[{{$.PhysicalDeviceIndex}}];  // trace w"
  "as captured on device {{$.PhysicalDeviceIndex}}\n    else\n      {{$physicalDevice}} = physicalDevices[{{$.PhysicalDevice"
  "Index}}];  // fallback to device 0\n  {{else}}\n    {{$physicalDevice}} = physicalDevices[0]; // trace was captured on de"
  "vice 0\n  {{end}}\n\n  {{template \"CPP.DeclareLocalVariable\" Dict \"obj\" $.physProps \"suffix\" \"_captured\"}}\n  vkG"
  "etPhysicalDeviceProperties({{$physicalDevice}}, &{{$physicalDeviceProps}});\n\n  {{template \"CPP.DeclareLocalVariable\" "
  "Dict \"obj\" $.memProps \"suffix\" \"_captured\"}}\n  {{$memoryPropsCap}} = {{template \"CPP.LocalVariableName\" Dict \"o"
  "bj\" $.memProps \"suffix\" \"_captured\"}};\n  vkGetPhysicalDeviceMemoryProperties({{$physicalDevice}}, &{{$memoryProps}}"
  ");\n  aux.physDeviceMemoryProperties = {{$memoryProps}};\n\n  {{template \"CPP.DeclareLocalVariable\" Dict \"obj\" $.phys"
  "Features \"suffix\" \"_captured\"}}\n  vkGetPhysicalDeviceFeatures({{$physicalDevice}}, &{{$physicalDeviceFeatures}});\n\n"
  "  {{template \"CPP.DeclareLocalVariable\" Dict \"obj\" $.queueProps \"suffix\" \"_captured\"}}\n  uint32_t queueFamilyCou"
  "nt = 0u;\n  vkGetPhysicalDeviceQueueFamilyProperties({{$physicalDevice}}, &queueFamilyCount, NULL);\n  {{$queueProps}}.re"
  "size(queueFamilyCount);\n  vkGetPhysicalDeviceQueueFamilyProperties({{$physicalDevice}}, &queueFamilyCount, {{$queueProps"
  "}}.data());\n  }\n{{end}}\n\n{{define \"Vulkan.vkEnumeratePhysicalDevices\"}}\n  {{ExecTemplate \"early_create.cpp\" \"Vu"
  "lkan.vkEnumeratePhysicalDevices.early\"}}\n{{end}}\n\n\n{{define \"Vulkan.vkGetDeviceQueue\"}}\n  {{Name $}}({{S}}\n  {{r"
  "ange $i, $argName, $arg := RemoveHidden $}}\n    {{if Gt $i 0}}, {{S}}{{end}}\n    {{if Eq $argName \"Queue\"}}&{{templat"
  "e \"CPP.GlobalVariable\" $arg}}{{S}}\n    {{else}}\n      {{template \"CPP.ArgValue\" $arg}}\n    {{end}}\n  {{end}}\n  )"
  ";\n{{end}}\n\n{{define \"Vulkan.vkCreateSwapchainKHR.Win32Surface\"}}\n  {{$hinstance := Macro \"CPP.GlobalVariable\" (Di"
  "ct \"type\" \"HINSTANCE\" \"name\" \"appHinstance\" \"value\" \"NULL\")}}\n  {{$hwnd := Macro \"CPP.GlobalVariable\" (Dic"
  "t \"type\" \"HWND\" \"name\" \"appHwnd\" \"value\" \"NULL\")}}\n\n  VkWin32SurfaceCreateInfoKHR surfaceCreateInfo = {\n  "
  "  /* sType = */ VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,\n    /* pNext = */ NULL,\n    /* flags = */ 0,\n    /* h"
  "instance = */ {{$hinstance}},\n    /* hwnd = */ {{$hwnd}},\n  };\n  CHECK_VK_SUCCESS(vkCreateWin32SurfaceKHR(aux.instance"
  ", &surfaceCreateInfo, NULL, &{{$}}));\n{{end}}\n\n{{define \"Vulkan.vkCreateSwapchainKHR\"}}\n  {{$_ := Macro \"CPP.Globa"
  "lVariable\" (Dict \"type\" \"const uint32_t\" \"name\" \"resolutionWidth\" \"value\" $.CreateInfo.imageExtent.width)}}\n "
  " {{$_ := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"const uint32_t\" \"name\" \"resolutionHeight\" \"value\" $.CreateI"
  "nfo.imageExtent.height)}}\n\n  {{$device := Macro \"CPP.GlobalVariable\" $.device}}\n  {{$surface := Macro \"CPP.GlobalVa"
  "riable\" (Dict \"type\" \"VkSurfaceKHR\" \"id\" $.SwapChain)}}\n  {{$swapchain := Macro \"CPP.GlobalVariable\" $.SwapChai"
  "n}}\n\n  {{$createWin32Surface := Macro \"Vulkan.vkCreateSwapchainKHR.Win32Surface\" $surface}}\n  {{template \"CPP.IfDef"
  "Platform\" Dict \"win32\" $createWin32Surface}}\n\n  {{$surfaceSupported := Macro \"CPP.GlobalVariable\" (Dict \"type\" \""
  "std::vector<VkBool32>\" \"name\" \"SurfaceSupported\" \"id\" $.SwapChain)}}\n  {{$queueFamilyProps := Macro \"Vulkan.Queu"
  "eFamilyPropertiesVar\"}}\n  {{$physDev := Macro \"Vulkan.PhysicalDeviceVar\"}}\n  {{$surfaceSupported}}.resize({{$queueFa"
  "milyProps}}.size());\n  for(uint32_t i=0; i<{{$surfaceSupported}}.size(); ++i) {\n    CHECK_VK_SUCCESS(vkGetPhysicalDevic"
  "eSurfaceSupportKHR({{$physDev}}, i, {{$surface}}, &{{$surfaceSupported}}[i]));\n  }\n  uint32_t surfaceFormatCount = 0;\n"
  "  CHECK_VK_SUCCESS(vkGetPhysicalDeviceSurfaceFormatsKHR({{$physDev}}, {{$surface}}, &surfaceFormatCount, NULL));\n  {{$su"
  "rfaceFormats := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"std::vector<VkSurfaceFormatKHR>\" \"name\" \"SurfaceFormats"
  "\" \"id\" $.SwapChain)}}\n  {{$surfaceFormats}}.resize(surfaceFormatCount);\n  CHECK_VK_SUCCESS(vkGetPhysicalDeviceSurfac"
  "eFormatsKHR({{$physDev}}, {{$surface}}, &surfaceFormatCount, {{$surfaceFormats}}.data()));\n  uint32_t presentModeCount ="
  " 0;\n  CHECK_VK_SUCCESS(vkGetPhysicalDeviceSurfacePresentModesKHR({{$physDev}}, {{$surface}}, &presentModeCount, NULL));\n"
  "  {{$surfacePresentModes := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"std::vector<VkPresentModeKHR>\" \"name\" \"Surf"
  "acePresentModes\" \"id\" $.SwapChain)}}\n  {{$surfacePresentModes}}.resize(presentModeCount);\n  CHECK_VK_SUCCESS(vkGetPh"
  "ysicalDeviceSurfacePresentModesKHR({{$physDev}}, {{$surface}}, &presentModeCount, {{$surfacePresentModes}}.data()));\n  {"
  "{$surfaceCapabilities := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"VkSurfaceCapabilitiesKHR\" \"id\" $.SwapChain)}}\n"
  "  CHECK_VK_SUCCESS(vkGetPhysicalDeviceSurfaceCapabilitiesKHR({{$physDev}}, {{$surface}}, &{{$surfaceCapabilities}}));\n  "
  "{{$}}\n\n  VkSwapchainCreateInfoKHR CreateInfo = {\n    {{range $childName, $child := $.CreateInfo | RemoveHidden}}\n    "
  "  /* {{Name $child}} = */ {{S}}\n      {{if Eq \"surface\" $childName}}\n        {{$surface}},\n      {{else}}\n        {"
  "{template \"CPP.Value\" $child}},\n      {{end}}\n    {{end}}\n  };\n  {{template \"CPP.DeclareArg\" $.pAllocator}}\n\n  "
  "CHECK_VK_SUCCESS({{Name $}}({{S}}\n    {{$device}}, {{S}}\n    &{{template \"CPP.ArgValue\" $.CreateInfo}}, {{S}}\n    {{"
  "template \"CPP.ArgValue\" $.pAllocator}}, {{S}}\n    &{{$swapchain}}));\n  {{$swapchainImages := Macro \"CPP.GlobalVariab"
  "le\" (Dict \"type\" \"std::vector<VkImage>\" \"name\" \"VkSwapchainKHR_images\" \"id\" $.SwapChain)}}\n  uint32_t swapcha"
  "inImageCount = 0u;\n  CHECK_VK_SUCCESS(vkGetSwapchainImagesKHR({{$device}}, {{$swapchain}}, &swapchainImageCount, NULL));"
  "\n  {{$swapchainImages}}.resize(swapchainImageCount);\n  CHECK_VK_SUCCESS(vkGetSwapchainImagesKHR({{$device}}, {{$swapcha"
  "in}}, &swapchainImageCount, {{$swapchainImages}}.data()));\n\n  {{$swapchainVirtualImages := Macro \"CPP.GlobalVariable\""
  " (Dict \"type\" \"std::vector<VkImage>\" \"name\" \"VkSwapchainKHR_virtual_images\" \"id\" $.SwapChain)}}\n  {{$swapchain"
  "VirtualImages}}.resize({{$.NumImages}});\n  aux.swapchain = {{$swapchain}};\n  aux.realSwapchainImages = {{$swapchainImag"
  "es}};\n  CHECK_VK_SUCCESS(CreateVirtualSwapchainImages(aux, {{template \"CPP.ArgValue\" $.CreateInfo}}, {{$swapchainVirtu"
  "alImages}}.data(), {{$.NumImages}}));\n{{end}}\n\n{{define \"Vulkan.vkGetSwapchainImagesKHR\"}}\n  {{$image := Macro \"CP"
  "P.GlobalVariable\" $.SwapchainImage}}\n  {{$swapchainVirtualImages := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"std::"
  "vector<VkImage>\" \"name\" \"VkSwapchainKHR_virtual_images\" \"id\" $.Swapchain)}}\n  {{$image}} = {{$swapchainVirtualIma"
  "ges}}[{{$.SwapchainImageIndex}}];\n{{end}}\n\n{{define \"Vulkan.vkCreateBuffer\"}}\n  {{$device := Macro \"CPP.GlobalVari"
  "able\" $.device}}\n  {{template \"CPP.DeclareLocalVariable\" $.CreateInfo}}\n  {{$createInfo := Macro \"CPP.LocalVariable"
  "Name\" $.CreateInfo}}\n  {{$allocator := Macro \"CPP.Value\" $.pAllocator}}\n  {{$buffer := Macro \"CPP.GlobalVariable\" "
  "$.Buffer}}\n  CHECK_VK_SUCCESS({{Name $}}({{$device}}, &{{$createInfo}}, {{$allocator}}, &{{$buffer}}));\n{{end}}\n\n{{de"
  "fine \"Vulkan.vkCreateImage\"}}\n  {{$device := Macro \"CPP.GlobalVariable\" $.device}}\n  {{template \"CPP.DeclareLocalV"
  "ariable\" $.CreateInfo}}\n  {{$createInfo := Macro \"CPP.LocalVariableName\" $.CreateInfo}}\n  {{$allocator := Macro \"CP"
  "P.Value\" $.pAllocator}}\n  {{$image := Macro \"CPP.GlobalVariable\" $.Image}}\n  CHECK_VK_SUCCESS({{Name $}}({{$device}}"
  ", &{{$createInfo}}, {{$allocator}}, &{{$image}}));\n{{end}}\n\n{{define \"Vulkan.vkBeginCommandBuffer\"}}\n  {{$commandBu"
  "ffer := Macro \"CPP.GlobalVariable\" $.CommandBuffer}}\n  {{template \"CPP.DeclareLocalVariable\" $.BeginInfo}}\n  {{$beg"
  "inInfo := Macro \"CPP.LocalVariableName\" $.BeginInfo}}\n  CHECK_VK_SUCCESS({{Name $}}({{$commandBuffer}}, &{{$beginInfo}"
  "}));\n{{end}}\n\n{{define \"Vulkan.vkEndCommandBuffer\"}}\n  {{$commandBuffer := Macro \"CPP.GlobalVariable\" $.CommandBu"
  "ffer}}\n  CHECK_VK_SUCCESS({{Name $}}({{$commandBuffer}}));\n{{end}}\n\n{{define \"Vulkan.vkCmdBeginRenderPass\"}}\n  {{$"
  "commandBuffer := Macro \"CPP.GlobalVariable\" $.commandBuffer}}\n  {{template \"CPP.DeclareLocalVariable\" $.RenderPassBe"
  "gin}}\n  {{$beginInfo := Macro \"CPP.LocalVariableName\" $.RenderPassBegin}}\n  {{Name $}}({{$commandBuffer}}, &{{$beginI"
  "nfo}}, {{$.contents}});\n{{end}}\n\n{{define \"Vulkan.vkFlushMappedMemoryRanges\"}}\n  {{template \"CPP.DeclareLocalVaria"
  "ble\" $.MemRange}}\n  {{$device := Macro \"CPP.GlobalVariable\" $.device}}\n  {{$memory := Macro \"CPP.GlobalVariable\" $"
  ".MemRange.memory}}\n  {{$allocateInfo := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"VkMemoryAllocateInfo\" \"id\" $.Me"
  "mRange.memory)}}\n  {{$remap := Macro \"CPP.GlobalVariable\" (Dict \"type\" \"MemoryRemapVec\" \"id\" $.MemRange.memory)}"
  "}\n  uint8_t* data = NULL;\n  CHECK_VK_SUCCESS(vkMapMemory({{$device}}, {{$memory}}, 0, VK_WHOLE_SIZE, 0, (void**)&data))"
  ";\n  MapUpdate(aux, data, {{template \"CPP.Value\" $.MappedData}}, MemRange, {{$allocateInfo}}, {{$remap}}, {{$device}});"
  "\n  vkUnmapMemory({{$device}}, {{$memory}});\n{{end}}\n\n{{define \"Vulkan.InitDeviceMemory\"}}\n  /* Initializing Device"
  " Memory: {{template \"CPP.Value\" $.id}} */\n{{end}}\n\n{{define \"Vulkan.InitImage\"}}\n  /* Initializing Image: {{templ"
  "ate \"CPP.Value\" $.id}} */\n{{end}}\n\n{{define \"Vulkan.InitDescriptorSet\"}}\n  /* Initializing Descriptor Set: {{temp"
  "late \"CPP.Value\" $.id}} */\n  {{$descSetAI := GetGlobal (Print \"VkDescriptorSetAI_\" (ToUInt $.id))}}\n  {{$layoutId :"
  "= $descSetAI.pSetLayouts | Index 0}}\n  {{$layoutCI := GetGlobal (Print \"VkDescriptorSetLayoutCI_\" ($layoutId | ToUInt)"
  ")}}\n  {{$descWrites := VkInitDescriptorSetWrites $ $layoutCI}}\n  {{template \"CPP.DeclareLocalVariable\" $descWrites}}\n"
  "  vkUpdateDescriptorSets({{template \"Vulkan.DeviceVar\"}}, {{Size $descWrites}}, {{template \"CPP.ArgValue\" $descWrites"
  "}}, 0, NULL);\n{{end}}\n\n{{define \"Vulkan.vkCreateDescriptorSetLayout\"}}\n  {{SetGlobal (Print \"VkDescriptorSetLayout"
  "CI_\" (ToUInt $.SetLayout)) $.CreateInfo}}\n  {{template \"Vulkan.vkCreate\"}}\n{{end}}\n\n{{define \"Vulkan.vkAllocateDe"
  "scriptorSets\"}}\n  {{SetGlobal (Print \"VkDescriptorSetAI_\" (ToUInt $.DescriptorSet)) $.AllocateInfo}}\n  {{template \""
  "Vulkan.vkCreate\"}}\n{{end}}\n\n{{define \"Vulkan.vkCreateDebugUtilsMessengerEXT.wrapper\"}}\n  {{if RegisterGlobalVar $."
  "name}}\n    VkResult vkCreateDebugUtilsMessengerEXT(VkInstance instance,\n        const VkDebugUtilsMessengerCreateInfoEX"
  "T* pCreateInfo,\n        const VkAllocationCallbacks* pAllocator,\n        VkDebugUtilsMessengerEXT* pMessenger) {\n     "
  " if({{$.pfn}} != NULL)\n        return {{$.pfn}}(instance, pCreateInfo, pAllocator, pMessenger);\n    }\n  {{end}}\n{{end"
  "}}\n\n{{define \"Vulkan.DriverInit.early\"}}\n  { /* vkCreateInstance */\n  {{$validationEnabled := Macro \"CPP.GlobalVar"
  "iable\" (Dict \"type\" \"bool\" \"name\" \"validation_enabled\" \"value\" \"true\")}};\n  {{$_ := Macro \"CPP.GlobalVaria"
  "ble\" (Dict \"type\" \"AuxVkTraceResources\" \"name\" \"aux\")}}\n  VkApplicationInfo pApplicationInfo[1] = {\n    /* sTy"
  "pe */ VK_STRUCTURE_TYPE_APPLICATION_INFO,\n    /* pNext */ NULL,\n    /* pApplicationName */ \"RenderDoc Capturing App\","
  " /* original: \"{{$.InitParams.AppName}}\" */\n    /* applicationVersion */ 0, /* original: {{$.InitParams.AppVersion}} *"
  "/\n    /* pEngineName */ \"RenderDoc\", /* original: \"{{$.InitParams.EngineName}}\" */\n    /* engineVersion */ 0, /* or"
  "iginal: \"{{$.InitParams.EngineVersion}} */\n    /* apiVersion */ {{$.InitParams.APIVersion}},\n  };\n  std::vector<const"
  " char *> enabledLayerNames = {\n    {{range $layer := $.InitParams.Layers}}\n      {{if Eq $layer \"VK_LAYER_RENDERDOC_Ca"
  "pture\"}}\n      {{else if Eq $layer \"VK_LAYER_LUNARG_standard_validation\"}}\n      {{else if Eq $layer \"VK_LAYER_KHRO"
  "NOS_validation\"}}\n      {{else}}\n        \"{{$layer}}\",\n      {{end}}\n    {{end}}\n  };\n  std::vector<const char *"
  "> enabledExtensionNames = {\n    {{range $ext := $.InitParams.Extensions}}\n      {{if Eq $ext \"VK_EXT_debug_report\"}}\n"
  "      {{else if Eq $ext \"VK_EXT_debug_utils\"}}\n      {{else}}\n        \"{{$ext}}\",\n      {{end}}\n    {{end}}\n  };"
  "\n  const void *pNext = NULL;\n  VkDebugUtilsMessengerCreateInfoEXT debugMessengerCreateInfo;\n  if({{$validationEnabled}"
  "}) {\n    enabledLayerNames.push_back(\"VK_LAYER_KHRONOS_validation\");\n    enabledExtensionNames.push_back(VK_EXT_DEBUG"
  "_UTILS_EXTENSION_NAME);\n    VkDebugUtilsMessageSeverityFlagsEXT messageSeverity =\n      VK_DEBUG_UTILS_MESSAGE_SEVERITY"
  "_VERBOSE_BIT_EXT |\n      VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |\n      VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_"
  "BIT_EXT;\n    VkDebugUtilsMessageTypeFlagsEXT messageType =\n      VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |\n      V"
  "K_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |\n      VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;\n    debugMesseng"
  "erCreateInfo = DebugUtilsMessengerCreateInfo(messageSeverity, messageType);\n    pNext = &debugMessengerCreateInfo;\n  }\n"
  "  VkInstanceCreateInfo pInstanceCreateInfo[1] = {\n    /* sType */ VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n    /* pNext "
  "*/ pNext,\n    /* flags */ 0,\n    /* pApplicationInfo */ pApplicationInfo,\n    /* enabledLayerCount */ (uint32_t)enable"
  "dLayerNames.size(),\n    /* ppEnabledLayerNames */ enabledLayerNames.data(),\n    /* enabledExtensionCount */ (uint32_t)e"
  "nabledExtensionNames.size(),\n    /* ppEnabledExtensionNames */ enabledExtensionNames.data(),\n  };\n  {{SetGlobal \"VkIn"
  "stance\" $.InitParams.InstanceID}}\n  {{$instance := Macro \"Vulkan.InstanceVar\"}}\n  {{$args := Array \"pInstanceCreate"
  "Info\" \"NULL\" (Print \"&\" $instance)}}\n  {{template \"CPP.CallFunction\" Dict \"name\" \"vkCreateInstance\" \"args\" "
  "$args \"check\" \"CHECK_VK_SUCCESS\"}}\n  aux.instance = {{$instance}};\n  if({{$validationEnabled}}) {\n    {{$pfnCreate"
  "DebugMessenger := Macro \"Vulkan.InstanceProcAddr\" \"vkCreateDebugUtilsMessengerEXT\"}}\n    {{ExecTemplate \"variables."
  "cpp\" \"Vulkan.vkCreateDebugUtilsMessengerEXT.wrapper\" (Dict \"pfn\" $pfnCreateDebugMessenger)}}\n    CHECK_VK_SUCCESS(v"
  "kCreateDebugUtilsMessengerEXT({{$instance}}, &debugMessengerCreateInfo, NULL, &aux.messenger));\n  }\n  }\n{{end}}\n\n{{d"
  "efine \"Vulkan.DeviceVar\"}}\n  {{template \"CPP.GlobalVariable\" (GetGlobal \"VkDevice\")}}\n{{end}}\n\n{{define \"Vulka"
  "n.vkCreateDevice.early\"}}\n  { /* vkCreateDevice */\n  {{SetGlobal \"VkDevice\" $.Device}}\n  {{$device := Macro \"Vulka"
  "n.DeviceVar\"}}\n  {{$physicalDevice := Macro \"CPP.GlobalVariable\" $.physicalDevice}}\n  {{$debugMarkerEnabled := false"
  "}}\n  {{$debugMarkerExt := \"VK_EXT_debug_marker\"}}\n  std::vector<const char *> enabledExtensions = {\n    {{range $ext"
  " := $.CreateInfo.ppEnabledExtensionNames}}\n      {{if Eq $ext $debugMarkerExt}}\n        {{$debugMarkerEnabled = true}}\n"
  "      {{else}}\n        {{template \"CPP.Value\" $ext}},\n      {{end}}\n    {{end}}\n  };\n  {{if $debugMarkerEnabled}}\n"
  "    if(IsExtSupported({{$physicalDevice}}, \"{{$debugMarkerExt}}\")) {\n      enabledExtensions.push_back(\"{{$debugMarke"
  "rExt}}\");\n    }\n  {{end}}\n  {{$ = SetCustomString $ \"CreateInfo.enabledExtensionCount\" \"(uint32_t)enabledExtension"
  "s.size()\"}}\n  {{$ = SetCustomString $ \"CreateInfo.ppEnabledExtensionNames\" \"enabledExtensions.data()\"}}\n  {{templa"
  "te \"Vulkan.vkCreate\" $}}\n  InitializeAuxResources(&aux, aux.instance, {{$physicalDevice}}, {{$device}});\n  }\n{{end}}"
  "\n\n{{define \"Vulkan.vkCreateDevice\"}}\n  {{ExecTemplate \"early_create.cpp\" \"Vulkan.vkCreateDevice.early\"}}\n{{end}"
  "}\n\n{{define \"CPP.InitialContentsList\"}}\n  /* Vulkan InitialContentsList */\n{{end}}\n\n{{define \"CPP.InitialContent"
  "s\"}}\n  /* Vulkan InitialContents */\n  {{$type := Print $.type}}\n  {{if Eq $type \"eResDeviceMemory\"}}\n    {{templat"
  "e \"Vulkan.InitDeviceMemory\"}}\n  {{else if Eq $type \"eResImage\"}}\n    {{template \"Vulkan.InitImage\"}}\n  {{else if"
  " Eq $type \"eResDescriptorSet\"}}\n    {{template \"Vulkan.InitDescriptorSet\"}}\n  {{else}}\n    UNKNOWN INITIAL CONTENT"
  "S TYPE: {{$type}}\n  {{end}}\n{{end}}\n\n{{define \"CPP.CaptureBegin\"}}\n  /* Vulkan CaptureBegin */\n  CHECK_VK_SUCCESS"
  "(AcquireVirtualSwapchainImage(aux, presented_image));\n{{end}}\n\n{{define \"CPP.CaptureScope\"}}\n  /* Vulkan CaptureSco"
  "pe */\n{{end}}\n\n{{define \"CPP.CaptureEnd\"}}\n  /* Vulkan CaptureEnd */\n  {{$_ := Macro \"CPP.GlobalVariable\" (Dict "
  "\"type\" \"VkImage&\" \"name\" \"presented_image\" \"value\" $.PresentedImage)}}\n  PresentVirtualSwapchainImage(aux, pre"
  "sented_image);\n  vkQueueWaitIdle(aux.queue);\n{{end}}\n\n{{define \"Vulkan.vkCreate\"}}\n  {{$name := Name $}}\n  {{$arg"
  "s := RemoveHidden $}}\n  {{range $arg := $args}}\n    {{template \"CPP.DeclareArg\" $arg}}\n  {{end}}\n  CHECK_VK_SUCCESS"
  "({{$name}}({{S}}\n  {{range $i, $argName, $arg := $args}}\n    {{if Gt $i 0}}, {{S}}{{end}}\n    {{if Eq (Add 1 $i) (Size"
  " $)}}\n      &{{Macro \"CPP.GlobalVariable\" $arg}}{{S}}\n    {{else}}\n      {{if Or (Eq \"CreateInfo\" $argName) (Eq \""
  "AllocateInfo\" $argName)}}&{{S}}{{end}}\n      {{template \"CPP.ArgValue\" $arg}}\n    {{end}}\n  {{end}}\n  ));\n{{end}}"
  "\n\n{{define \"CPP.DriverInit\"}}\n  {{ExecTemplate \"early_create.cpp\" \"Vulkan.DriverInit.early\"}}\n{{end}}\n\n{{defi"
  "ne \"Vulkan.vkCmdDebugMarkerBeginEXT.wrapper\"}}\n  {{if RegisterGlobalVar $.name}}\n    void vkCmdDebugMarkerBeginEXT(Vk"
  "CommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {\n      if({{$.pfn}} != NULL)\n        {{$.p"
  "fn}}(commandBuffer, pMarkerInfo);\n    }\n  {{end}}\n{{end}}\n\n{{define \"Vulkan.vkCmdDebugMarkerBeginEXT\"}}\n  {{$pfn "
  ":= Macro \"Vulkan.DeviceProcAddr\"}}\n  {{$ = MakePointer $ \"pMarker\"}}\n  {{ExecTemplate \"variables.cpp\" \"Vulkan.vk"
  "CmdDebugMarkerBeginEXT.wrapper\" (Dict \"name\" (Name $) \"pfn\" $pfn)}}\n  {{template \"CPP.CallFunction\" $}}\n{{end}}\n"
  "\n{{define \"Vulkan.vkCmdDebugMarkerEndEXT.wrapper\"}}\n  {{if RegisterGlobalVar $.name}}\n    void vkCmdDebugMarkerEndEX"
  "T(VkCommandBuffer commandBuffer) {\n      if({{$.pfn}} != NULL)\n        {{$.pfn}}(commandBuffer);\n    }\n  {{end}}\n{{e"
  "nd}}\n\n{{define \"Vulkan.vkCmdDebugMarkerEndEXT\"}}\n  {{$pfn := Macro \"Vulkan.DeviceProcAddr\"}}\n  {{ExecTemplate \"v"
  "ariables.cpp\" \"Vulkan.vkCmdDebugMarkerEndEXT.wrapper\" (Dict \"name\" (Name $) \"pfn\" $pfn)}}\n  {{template \"CPP.Call"
  "Function\" $}}\n{{end}}\n\n{{define \"CPP.ChunkBody\"}}\n  {{$name := Name $}}\n  {{     if Eq $name \"vkEnumeratePhysica"
  "lDevices\"}}\n    {{template \"Vulkan.vkEnumeratePhysicalDevices\"}}\n  {{else if Eq $name \"vkCreateDevice\"}}\n    {{te"
  "mplate \"Vulkan.vkCreateDevice\"}}\n  {{else if Eq  $name \"vkCreateSwapchainKHR\"}}\n    {{template \"Vulkan.vkCreateSwa"
  "pchainKHR\"}}\n  {{else if Eq  $name \"vkGetSwapchainImagesKHR\"}}\n    {{template \"Vulkan.vkGetSwapchainImagesKHR\"}}\n"
  "  {{else if Eq  $name \"vkGetDeviceQueue\"}}\n    {{template \"Vulkan.vkGetDeviceQueue\"}}\n  {{else if Eq $name \"vkCrea"
  "teBuffer\"}}\n    {{template \"Vulkan.vkCreateBuffer\"}}\n  {{else if Eq $name \"vkCreateImage\"}}\n    {{template \"Vulk"
  "an.vkCreateImage\"}}\n  {{else if Eq $name \"vkCreateDescriptorSetLayout\"}}\n    {{template \"Vulkan.vkCreateDescriptorS"
  "etLayout\"}}\n  {{else if Eq $name \"vkAllocateDescriptorSets\"}}\n    {{template \"Vulkan.vkAllocateDescriptorSets\"}}\n"
  "  {{else if Eq $name \"vkBeginCommandBuffer\"}}\n    {{template \"Vulkan.vkBeginCommandBuffer\"}}\n  {{else if Eq $name \""
  "vkEndCommandBuffer\"}}\n    {{template \"Vulkan.vkEndCommandBuffer\"}}\n  {{else if Eq $name \"vkCmdBeginRenderPass\"}}\n"
  "    {{template \"Vulkan.vkCmdBeginRenderPass\"}}\n  {{else if Eq $name \"vkFlushMappedMemoryRanges\"}}\n    {{template \""
  "Vulkan.vkFlushMappedMemoryRanges\"}}\n  {{else if Eq $name \"vkCmdDebugMarkerBeginEXT\"}}\n    {{template \"Vulkan.vkCmdD"
  "ebugMarkerBeginEXT\"}}\n  {{else if Eq $name \"vkCmdDebugMarkerEndEXT\"}}\n    {{template \"Vulkan.vkCmdDebugMarkerEndEXT"
  "\"}}\n  {{else if Or ($name | StartsWith \"vkCreate\") ($name | StartsWith \"vkAllocate\")}}\n    {{template \"Vulkan.vkC"
  "reate\"}}\n  {{else if Eq $name \"Internal: Device Memory References\"}}\n  {{else if Eq $name \"Image Memory References\""
  "}}\n  {{else}}\n    {{template \"CPP.ChunkBody.Default\"}}\n  {{end}}\n{{end}}\n\n{{define \"Vulkan.BeginAuxCmdBuffer\"}}"
  "\n  CHECK_VK_SUCCESS(vkResetFences(aux.device, 1, &aux.fence));\n    VkCommandBufferBeginInfo cmd_buffer_bi = {\n      /*"
  " sType = */ VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      /* pNext = */ NULL,\n      /* flags = */ 0,\n      /* pIn"
  "heritanceInfo = */ NULL,\n    };\n  CHECK_VK_SUCCESS(vkBeginCommandBuffer(aux.command_buffer, &cmd_buffer_bi));\n{{end}}\n"
  "\n{{define \"Vulkan.EndAuxCmdBuffer\"}}\n  CHECK_VK_SUCCESS(vkEndCommandBuffer(aux.command_buffer));\n  VkSubmitInfo si ="
  " {\n    /* sType = */ VK_STRUCTURE_TYPE_SUBMIT_INFO,\n    /* pNext = */ NULL,\n    /* waitSemaphoreCount = */ 0,\n    /* "
  "pWaitSemaphores = */ NULL,\n    /* pWaitDstStageMask = */ NULL,\n    /* commandBufferCount = */ 1,\n    /* pCommandBuffer"
  "s */ &aux.command_buffer,\n    /* signalSemaphoreCount = */ 0,\n    /* pSignalSemaphores = */ NULL,\n  };\n  CHECK_VK_SUC"
  "CESS(vkQueueSubmit(aux.queue, 1, &si, aux.fence));\n  CHECK_VK_SUCCESS(vkQueueWaitIdle(aux.queue));\n{{end}}\n\n{{define "
  "\"Vulkan.InstanceProcAddr.get\"}}\n  {{$.pfn}} = ({{$.type}})vkGetInstanceProcAddr({{template \"Vulkan.InstanceVar\"}}, \""
  "{{$.name}}\");\n{{end}}\n{{define \"Vulkan.InstanceProcAddr\"}}\n  {{$name := $}}\n  {{if IsSDObject $}}\n    {{$name = N"
  "ame $}}\n  {{end}}\n  {{$type := Print \"PFN_\" $name }}\n  {{$pfn := Print \"pfn\" $name}}\n  {{template \"CPP.GlobalVar"
  "iable\" Dict \"type\" $type \"name\" $pfn \"value\" \"VK_NULL_HANDLE\"}}\n  {{ExecTemplate \"early_create.cpp\" \"Vulkan."
  "InstanceProcAddr.get\" (Dict \"type\" $type \"name\" $name \"pfn\" $pfn)}}\n{{end}}\n\n{{define \"Vulkan.DeviceProcAddr.g"
  "et\"}}\n  {{$.pfn}} = ({{$.type}})vkGetDeviceProcAddr({{template \"Vulkan.DeviceVar\"}}, \"{{$.name}}\");\n{{end}}\n\n{{d"
  "efine \"Vulkan.DeviceProcAddr\"}}\n  {{$name := $}}\n  {{if IsSDObject $}}\n    {{$name = Name $}}\n  {{end}}\n  {{$type "
  ":= Print \"PFN_\" $name }}\n  {{$pfn := Print \"pfn\" $name}}\n  {{template \"CPP.GlobalVariable\" Dict \"type\" $type \""
  "name\" $pfn \"value\" \"VK_NULL_HANDLE\"}}\n  {{ExecTemplate \"early_create.cpp\" \"Vulkan.DeviceProcAddr.get\" (Dict \"t"
  "ype\" $type \"name\" $name \"pfn\" $pfn)}}\n{{end}}\n\n{{define \"CPP.PhaseMain\"}}\n  {{$needsCmdBuf := Or (Eq $.phase \""
  "init\") (Eq $.phase \"reset\")}}\n  {{$needsProgress := Or (Eq $.phase \"early_create\") (Eq $.phase \"create\") (Eq $.ph"
  "ase \"init\")}}\n  void main_{{$.phase}}() {\n    {{if $needsCmdBuf}}\n      CHECK_VK_SUCCESS(vkResetFences(aux.device, 1"
  ", &aux.fence));\n      VkCommandBufferBeginInfo cmd_buffer_bi = {\n        /* sType = */ VK_STRUCTURE_TYPE_COMMAND_BUFFER"
  "_BEGIN_INFO,\n        /* pNext = */ NULL,\n        /* flags = */ 0,\n        /* pInheritanceInfo = */ NULL,\n      };\n  "
  "    CHECK_VK_SUCCESS(vkBeginCommandBuffer(aux.command_buffer, &cmd_buffer_bi));\n    {{end}}\n    {{range $i := Range $.c"
  "ount}}\n      {{if $needsProgress}}\n        PostStageProgress(\"{{$.phase}}\", {{Add 1 $i}}, {{$.count}});\n      {{end}"
  "}\n      {{$.phase}}_{{$i}}();\n    {{end}}\n    {{if $needsCmdBuf}}\n      CHECK_VK_SUCCESS(vkEndCommandBuffer(aux.comma"
  "nd_buffer));\n      VkSubmitInfo si = {\n        /* sType = */ VK_STRUCTURE_TYPE_SUBMIT_INFO,\n        /* pNext = */ NULL"
  ",\n        /* waitSemaphoreCount = */ 0,\n        /* pWaitSemaphores = */ NULL,\n        /* pWaitDstStageMask = */ NULL,\n"
  "        /* commandBufferCount = */ 1,\n        /* pCommandBuffers = */ &aux.command_buffer,\n        /* signalSemaphoreCo"
  "unt = */ 0,\n        /* pSignalSemaphores = */ NULL,\n      };\n      CHECK_VK_SUCCESS(vkQueueSubmit(aux.queue, 1, &si, a"
  "ux.fence));\n      CHECK_VK_SUCCESS(vkWaitForFences(aux.device, 1, &aux.fence, VK_TRUE, ~0ull));\n    {{end}}\n  }\n{{end"
  "}}";
const char fileData_3[] =
  "@echo off\r\nsetlocal enableextensions\r\nrd /s /q _build_files\\win_vs2015x64 2>nul\r\nmkdir _build_files\\win_vs2015x64"
  "\r\ncmake.exe -Wno-dev -G \"Visual Studio 14 2015 Win64\" \"\" -H. -B_build_files\\win_vs2015x64\r\nexit /b %errorlevel%\r"
  "\n";
const char fileData_4[] =
  "@echo off\r\nsetlocal enableextensions\r\nset BUILD_TYPE=Release\r\nif NOT \"%1\" == \"\" set BUILD_TYPE=%~1\r\nrd /s /q "
  "_build_files\\win_vs2015x64_ninja 2>nul\r\nmkdir _build_files\\win_vs2015x64_ninja\r\ncall \"C:\\Program Files (x86)\\Mic"
  "rosoft Visual Studio 14.0\\VC\\vcvarsall.bat\" x64\r\ncmake.exe -Wno-dev -G Ninja --build \"\" -H. -B_build_files\\win_vs"
  "2015x64_ninja -DCMAKE_BUILD_TYPE=%BUILD_TYPE%\r\nninja -C _build_files\\win_vs2015x64_ninja\r\nexit /b %errorlevel%\r\n";
const char fileData_5[] =
  "@echo off\r\nsetlocal enableextensions\r\nrd /s /q _build_files\\win_vs2017x64 2>nul\r\nmkdir _build_files\\win_vs2017x64"
  "\r\ncmake.exe -Wno-dev -G \"Visual Studio 15 2017 Win64\" \"\" -H. -B_build_files\\win_vs2017x64\r\nexit /b %errorlevel%\r"
  "\n";
const char fileData_6[] =
  "@echo off\r\nsetlocal enableextensions\r\nset BUILD_TYPE=Release\r\nif NOT \"%1\" == \"\" set BUILD_TYPE=%~1\r\nrd /s /q "
  "_build_files\\win_vs2017x64_ninja 2>nul\r\nmkdir _build_files\\win_vs2017x64_ninja\r\ncall \"C:\\Program Files (x86)\\Mic"
  "rosoft Visual Studio\\2017\\Professional\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x64\r\ncmake.exe -Wno-dev -G Ninja --buil"
  "d \"\" -H. -B_build_files\\win_vs2017x64_ninja -DCMAKE_BUILD_TYPE=%BUILD_TYPE%\r\nninja -C _build_files\\win_vs2017x64_ni"
  "nja\r\nexit /b %errorlevel%\r\n";
const char fileData_7[] =
  "@echo off\r\nsetlocal enableextensions\r\nrd /s /q _build_files\\win_vs2019x64 2>nul\r\nmkdir _build_files\\win_vs2019x64"
  "\r\ncmake.exe -Wno-dev -G \"Visual Studio 16 2019\" -A \"x64\" \"\" -H. -B_build_files\\win_vs2019x64\r\nexit /b %errorle"
  "vel%\r\n";
const char fileData_8[] =
  "@echo off\r\nsetlocal enableextensions\r\nset BUILD_TYPE=Release\r\nif NOT \"%1\" == \"\" set BUILD_TYPE=%~1\r\nrd /s /q "
  "_build_files\\win_vs2019x64_ninja 2>nul\r\nmkdir _build_files\\win_vs2019x64_ninja\r\ncall \"C:\\Program Files (x86)\\Mic"
  "rosoft Visual Studio\\2019\\Professional\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x64\r\ncmake.exe -Wno-dev -G Ninja --buil"
  "d \"\" -H. -B_build_files\\win_vs2019x64_ninja -DCMAKE_BUILD_TYPE=%BUILD_TYPE%\r\nninja -C _build_files\\win_vs2019x64_ni"
  "nja\r\nexit /b %errorlevel%\r\n";
const char fileData_9[] =
  "CMAKE_MINIMUM_REQUIRED (VERSION 3.9)\r\n# Disable some of the default cmake build targets, keep debug and release\r\nSET "
  "(CMAKE_CONFIGURATION_TYPES Debug Release CACHE TYPE INTERNAL FORCE)\r\nPROJECT(renderdoc_gen_frame)\r\n\r\nSET (WORKING_D"
  "IRECTORY_DEBUG      \"../../../\")\r\nSET (WORKING_DIRECTORY_RELEASE    \"../../../\")\r\nSET (MSVS_USERFILE             "
  "   \"${PROJECT_SOURCE_DIR}/Template.user\")\r\n\r\nSET (PROJECT_PREFIX               \"\")\r\nSET (MACHINE_POSTFIX       "
  "       \"\")\r\nSET (USERFILE_PLATFORM            \"\")\r\n\r\nSET (MACHINE_IS_X64               TRUE)\r\nSET (CMAKE_CXX_"
  "STANDARD           11)\r\n\r\nIF (\"${CMAKE_SIZEOF_VOID_P}\"      EQUAL \"8\")\r\n  SET (MACHINE_IS_X64  TRUE)\r\nELSEIF "
  "(\"${CMAKE_SIZEOF_VOID_P}\"  EQUAL \"4\")\r\n  SET (MACHINE_IS_X64 FALSE)\r\nENDIF ()\r\n\r\nIF (WIN32)\r\n  IF (MACHINE_"
  "IS_X64)\r\n    SET (MACHINE_POSTFIX            \"_x64\")\r\n    SET (USERFILE_PLATFORM          \"x64\")\r\n  ELSE ()\r\n"
  "    SET (MACHINE_POSTFIX            \"_x86\")\r\n    SET (USERFILE_PLATFORM          \"Win32\")\r\n  ENDIF ()\r\n  IF (MS"
  "VC)\r\n    SET (PROJECT_PREFIX               \"vs${MSVC_TOOLSET_VERSION}_\")\r\n  ENDIF ()\r\nENDIF ()\r\n\r\nGET_FILENAM"
  "E_COMPONENT(Trace ${CMAKE_CURRENT_SOURCE_DIR} NAME)\r\nSTRING(REPLACE \" \" \"_\" Trace ${Trace})\r\nPROJECT(${PROJECT_PR"
  "EFIX}${Trace}${MACHINE_POSTFIX})\r\n\r\nOPTION (OPTION_TREAT_WARNINGS_AS_ERRORS\r\n  \"Check if you want to treat warning"
  "s as errors\" FALSE)\r\n\r\nOPTION(ENABLE_SHIM \"Enable shim_vulkan dependency\" OFF)\r\n\r\nIF(EXISTS ${CMAKE_SOURCE_DIR"
  "}/shim.enable)\r\n  MESSAGE(STATUS \"shim_vulkan dependency was enabled\")\r\n  SET(ENABLE_SHIM ON)\r\nELSE()\r\n  MESSAG"
  "E(STATUS \"${CMAKE_SOURCE_DIR}/shim.enable not present\")\r\n  MESSAGE(STATUS \"shim_vulkan dependency was disabled\")\r\n"
  "  SET(ENABLE_SHIM OFF)\r\nENDIF()\r\n\r\nIF (MSVC)\r\n  SET (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /bigobj\")\r\n  IF (OPT"
  "ION_TREAT_WARNINGS_AS_ERRORS)\r\n    SET (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /WX\")\r\n  ENDIF (OPTION_TREAT_WARNINGS_A"
  "S_ERRORS)\r\nELSEIF (UNIX)\r\n  SET (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-narrowing\")\r\nENDIF()\r\n\r\nIF (WIN32)\r"
  "\n  SET (PLATFORM_OUT_DIR \"win\")\r\nELSE ()\r\n  SET (PLATFORM_OUT_DIR \"linux\")\r\nENDIF ()\r\n\r\nSET (EXECUTABLE_OU"
  "TPUT_PATH \"${CMAKE_SOURCE_DIR}/_out/${PLATFORM_OUT_DIR}${MACHINE_POSTFIX}\")\r\nSET (LIBRARY_OUTPUT_PATH    \"${CMAKE_SO"
  "URCE_DIR}/_out/${PLATFORM_OUT_DIR}${MACHINE_POSTFIX}\")\r\n\r\nSET (DEBUG_POSTFIX \"_DEBUG\" CACHE STRING \"Debug Postfix"
  "\")\r\nSET (CMAKE_RELEASE_POSTFIX \"\" CACHE STRING \"Release Postfix\")\r\nSET (CMAKE_MINSIZEREL_POSTFIX \"_MINSIZEREL\""
  " CACHE STRING \"Minimum Size Release Postfix\")\r\nSET (CMAKE_RELWITHDEBINFO_POSTFIX \"_RELWITHDEBINFO\" CACHE STRING \"R"
  "elease With Debug Info Postfix\")\r\n\r\n###############################################################################\r"
  "\n# Function that changes output names, adding the prefix and postfix\r\n################################################"
  "###############################\r\nFUNCTION (SETUP_PROJECT target)\r\n  SET_TARGET_PROPERTIES (${target} PROPERTIES\r\n  "
  "                       OUTPUT_NAME_DEBUG   ${target}${MACHINE_POSTFIX}${DEBUG_POSTFIX}\r\n                         OUTPUT"
  "_NAME_RELEASE ${target}${MACHINE_POSTFIX})\r\n  SET (USER_FILE ${target}.vcxproj.user)\r\n  SET (USERFILE_WORKING_DIRECTO"
  "RY_DEBUG   ${WORKING_DIRECTORY_DEBUG}${target})\r\n  SET (USERFILE_WORKING_DIRECTORY_RELEASE ${WORKING_DIRECTORY_RELEASE}"
  "${target})\r\n  SET (OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/${USER_FILE})\r\n  CONFIGURE_FILE (${MSVS_USERFILE} ${OUTPUT"
  "_PATH} @ONLY)\r\nENDFUNCTION ()\r\n\r\n###############################################################################\r\n"
  "# Search for Vulkan\r\n###############################################################################\r\nFIND_PACKAGE (V"
  "ulkan)\r\n  MESSAGE (STATUS \"Vulkan SDK                : $ENV{VULKAN_SDK}\")\r\nIF (Vulkan_FOUND)\r\n  MESSAGE (STATUS \""
  "Vulkan Includes           : ${Vulkan_INCLUDE_DIRS}\")\r\n  MESSAGE (STATUS \"Vulkan Libraries          : ${Vulkan_LIBRARI"
  "ES}\")\r\nELSE ()\r\n  MESSAGE (FATAL_ERROR \"Vulkan not found at $ENV{VULKAN_SDK}!\")\r\nENDIF ()\r\n\r\nADD_LIBRARY (vu"
  "lkan STATIC IMPORTED)\r\n\r\nSET_TARGET_PROPERTIES (vulkan PROPERTIES\r\n                       INTERFACE_INCLUDE_DIRECTO"
  "RIES ${Vulkan_INCLUDE_DIRS}\r\n                       IMPORTED_LOCATION             ${Vulkan_LIBRARIES})\r\n\r\nSET_PROPE"
  "RTY(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT sample_cpp_trace)\r\n\r\n##########################"
  "#####################################################\r\n# List Cmake projects\r\n#######################################"
  "########################################\r\nINCLUDE_DIRECTORIES(\"${CMAKE_SOURCE_DIR}\")\r\n\r\nADD_SUBDIRECTORY(\"${CMAK"
  "E_SOURCE_DIR}/sample_cpp_trace\"\r\n                 \"${CMAKE_BINARY_DIR}/sample_cpp_trace\")\r\nADD_SUBDIRECTORY(\"${CM"
  "AKE_SOURCE_DIR}/helper\"\r\n                 \"${CMAKE_BINARY_DIR}/helper\")\r\n# ADD_SUBDIRECTORY(\"${CMAKE_SOURCE_DIR}/"
  "sample_cpp_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/sample_cpp_shim\")\r\n# ADD_SUBDIRECTORY(\"${CMAKE_SOURCE_D"
  "IR}/gold_reference_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/gold_reference_shim\")\r\n# ADD_SUBDIRECTORY(\"${CM"
  "AKE_SOURCE_DIR}/profiling_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/profiling_shim\")\r\n# ADD_SUBDIRECTORY(\"${"
  "CMAKE_SOURCE_DIR}/amd_shader_info_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/amd_shader_info_shim\")\r\n# ADD_SUB"
  "DIRECTORY(\"${CMAKE_SOURCE_DIR}/rdoc_auto_capture_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/rdoc_auto_capture_sh"
  "im\")\r\n# ADD_SUBDIRECTORY(\"${CMAKE_SOURCE_DIR}/validation_shim\"\r\n#                  \"${CMAKE_BINARY_DIR}/validatio"
  "n_shim\")\r\n";
const char fileData_10[] =
  "\xef\xbb\xbf<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft."
  "com/developer/msbuild/2003\">\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|@USERFILE_PLATFORM@'"
  "\">\r\n    <LocalDebuggerCommandArguments></LocalDebuggerCommandArguments>\r\n    <DebuggerFlavor>WindowsLocalDebugger</D"
  "ebuggerFlavor>\r\n    <LocalDebuggerWorkingDirectory>@USERFILE_WORKING_DIRECTORY_DEBUG@</LocalDebuggerWorkingDirectory>\r"
  "\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|@USERFILE_PLATFORM@'\">\r\n"
  "    <LocalDebuggerCommandArguments></LocalDebuggerCommandArguments>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\""
  "'$(Configuration)|$(Platform)'=='Release|@USERFILE_PLATFORM@'\">\r\n    <LocalDebuggerWorkingDirectory>@USERFILE_WORKING_"
  "DIRECTORY_RELEASE@</LocalDebuggerWorkingDirectory>\r\n    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>\r\n  </Pr"
  "opertyGroup>\r\n</Project>";
const char fileData_11[] =
  "SET (THIS_PROJECT_NAME helper)\r\nPROJECT(${THIS_PROJECT_NAME})\r\n\r\nADD_LIBRARY(${THIS_PROJECT_NAME} STATIC \"helper.h"
  "\" \"helper.cpp\"\r\n             format_helper.h format_size_and_aspect.cpp)\r\n\r\nTARGET_COMPILE_DEFINITIONS(${THIS_PR"
  "OJECT_NAME}\r\n    PRIVATE UNICODE _UNICODE)\r\nIF (NOT WIN32)\r\n    TARGET_COMPILE_DEFINITIONS(${THIS_PROJECT_NAME}\r\n"
  "        PRIVATE HELPER_COMPILE_STATIC_LIB)\r\nENDIF ()\r\n\r\nTARGET_LINK_LIBRARIES(${THIS_PROJECT_NAME} vulkan)\r\n\r\nS"
  "ET_TARGET_PROPERTIES(${THIS_PROJECT_NAME} PROPERTIES\r\n                      OUTPUT_NAME ${THIS_PROJECT_NAME}\r\n       "
  "               ARCHIVE_OUTPUT_DIRECTORY \"${LIBRARY_OUTPUT_PATH}/${THIS_PROJECT_NAME}\"\r\n                      RUNTIME_"
  "OUTPUT_DIRECTORY \"${LIBRARY_OUTPUT_PATH}/${THIS_PROJECT_NAME}\"\r\n                      LIBRARY_OUTPUT_DIRECTORY \"${LI"
  "BRARY_OUTPUT_PATH}/${THIS_PROJECT_NAME}\"\r\n                      POSITION_INDEPENDENT_CODE ON)\r\n";
const char fileData_12[] =
  "/******************************************************************************\r\n* The MIT License (MIT)\r\n*\r\n* Copy"
  "right (c) 2018 Google LLC\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of "
  "this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, in"
  "cluding without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*"
  " copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following "
  "conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in\r\n* all copies or subst"
  "antial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r"
  "\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NO"
  "NINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIA"
  "BILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE"
  " OR THE USE OR OTHER DEALINGS IN\r\n* THE SOFTWARE.\r\n******************************************************************"
  "************/\r\n#pragma once\r\n\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <memory.h>\r\n#include <stdint."
  "h>\r\n#include <stdio.h>\r\n#if defined(_WIN32)\r\n#include <Windows.h>\r\n#endif\r\n\r\n#include <algorithm>\r\n#include"
  " <map>\r\n#include <string>\r\n#include <unordered_map>\r\n#include <vector>\r\n\r\n#include \"vulkan/vulkan.h\"\r\n\r\nb"
  "ool CheckFormatValid(VkFormat format);\r\nVkImageAspectFlags GetImageAspect(VkFormat format);\r\nuint32_t GetImageByteSiz"
  "e(VkFormat format);\r\n\r\ndouble SizeOfFormat(VkFormat fmt, VkImageAspectFlagBits aspect);\r\nuint32_t ChannelsInFormat("
  "VkFormat fmt);\r\nbool isHDRFormat(VkFormat fmt);\r\nbool IsFPFormat(VkFormat fmt);\r\nbool IsSignedFormat(VkFormat fmt);"
  "\r\nbool IsDepthFormat(VkFormat fmt);\r\nuint32_t BitsPerChannelInFormat(VkFormat fmt,\r\n                               "
  " VkImageAspectFlagBits aspect = VK_IMAGE_ASPECT_COLOR_BIT);\r\nVkImageAspectFlags FullAspectFromFormat(VkFormat fmt);\r\n"
  "VkImageAspectFlags AspectFromFormat(VkFormat fmt);\r\nuint32_t FixCompressedSizes(VkFormat fmt, VkExtent3D &dim, uint32_t"
  " &offset);\r\nstd::string FormatToString(VkFormat f);\r\nuint32_t MinDimensionSize(VkFormat format);\r\n";
const char fileData_13[] =
  "/******************************************************************************\r\n* The MIT License (MIT)\r\n*\r\n* Copy"
  "right (c) 2018 Google LLC\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of "
  "this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, in"
  "cluding without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*"
  " copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following "
  "conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in\r\n* all copies or subst"
  "antial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r"
  "\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NO"
  "NINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIA"
  "BILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE"
  " OR THE USE OR OTHER DEALINGS IN\r\n* THE SOFTWARE.\r\n******************************************************************"
  "************/\r\n#include \"format_helper.h\"\r\n#include \"helper.h\"\r\n\r\n#define FORMAT_ASPECT_BYTE_SIZE(f, a, bs)  "
  "                                               \\\r\n  {                                                                 "
  "                      \\\r\n    VK_FORMAT_##f, std::pair<VkImageAspectFlags, uint32_t>(VK_IMAGE_ASPECT_##a##_BIT, bs) \\\r"
  "\n  }\r\n\r\nstatic const std::map<VkFormat, std::pair<VkImageAspectFlags, uint32_t>> &GetImageAspectsAndByteSize()\r\n{\r"
  "\n  static std::map<VkFormat, std::pair<VkImageAspectFlags, uint32_t>> kImageAspectsAndByteSize = {\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(A8B8G8R8_USCALED_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R5G5B5A1_UNORM_PACK16, COLOR, 2),\r\n   "
  "   FORMAT_ASPECT_BYTE_SIZE(B8G8R8A8_UINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_SFLOAT, COLOR, 6),\r\n   "
  "   FORMAT_ASPECT_BYTE_SIZE(A2R10G10B10_SNORM_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32_UINT, COLOR, 4),\r\n"
  "      FORMAT_ASPECT_BYTE_SIZE(B8G8R8_UINT, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64_UINT, COLOR, 8),\r\n      FORM"
  "AT_ASPECT_BYTE_SIZE(R32G32B32_UINT, COLOR, 12),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8_SRGB, COLOR, 3),\r\n      FORMAT_"
  "ASPECT_BYTE_SIZE(B8G8R8A8_SINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8A8_SINT, COLOR, 4),\r\n      FORMAT_ASP"
  "ECT_BYTE_SIZE(R16G16_USCALED, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8A8_USCALED, COLOR, 4),\r\n      FORMAT_AS"
  "PECT_BYTE_SIZE(R8G8_UNORM, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64_UINT, COLOR, 16),\r\n      FORMAT_ASPECT_BY"
  "TE_SIZE(R8G8B8A8_SSCALED, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8_UNORM, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SI"
  "ZE(R8G8B8_SNORM, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8A8_UNORM, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE("
  "R16_USCALED, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_SSCALED, COLOR, 6),\r\n      FORMAT_ASPECT_BYTE_SIZE(R"
  "32G32B32A32_UINT, COLOR, 16),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_UINT, COLOR, 6),\r\n      FORMAT_ASPECT_BYTE_SIZ"
  "E(R8_USCALED, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8_SSCALED, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B"
  "16_USCALED, COLOR, 6),\r\n      FORMAT_ASPECT_BYTE_SIZE(R4G4_UNORM_PACK8, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2R"
  "10G10B10_UINT_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64_SINT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(R"
  "8G8_SSCALED, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16A16_SFLOAT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE"
  "(R64G64_SINT, COLOR, 16),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8A8_UINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2B"
  "10G10R10_SSCALED_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2R10G10B10_UNORM_PACK32, COLOR, 4),\r\n      FORMAT"
  "_ASPECT_BYTE_SIZE(R32G32_UINT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(R4G4B4A4_UNORM_PACK16, COLOR, 2),\r\n      FOR"
  "MAT_ASPECT_BYTE_SIZE(B8G8R8_SRGB, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_SNORM_PACK32, COLOR, 4),\r\n      "
  "FORMAT_ASPECT_BYTE_SIZE(R16G16B16A16_UNORM, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16A16_SSCALED, COLOR, 8),\r"
  "\n      FORMAT_ASPECT_BYTE_SIZE(R8_SINT, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32_SFLOAT, COLOR, 4),\r\n      FORM"
  "AT_ASPECT_BYTE_SIZE(R8G8B8A8_SNORM, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16A16_SNORM, COLOR, 8),\r\n      F"
  "ORMAT_ASPECT_BYTE_SIZE(R8G8B8_SINT, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8_SNORM, COLOR, 2),\r\n      FORMAT_AS"
  "PECT_BYTE_SIZE(R16G16B16A16_SINT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_SINT_PACK32, COLOR, 4),\r\n      F"
  "ORMAT_ASPECT_BYTE_SIZE(R8_SRGB, COLOR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8_USCALED, COLOR, 3),\r\n      FORMAT_AS"
  "PECT_BYTE_SIZE(B8G8R8A8_SRGB, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16_UNORM, COLOR, 2),\r\n      FORMAT_ASPECT_BY"
  "TE_SIZE(R8G8B8A8_SRGB, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2R10G10B10_USCALED_PACK32, COLOR, 4),\r\n      FORMAT"
  "_ASPECT_BYTE_SIZE(R16G16_SINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16_SNORM, COLOR, 4),\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(R8G8B8_USCALED, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_UNORM, COLOR, 6),\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(R16G16B16A16_UINT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16_SSCALED, COLOR, 4),\r\n      FORMAT_ASP"
  "ECT_BYTE_SIZE(R16_SNORM, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2R10G10B10_SINT_PACK32, COLOR, 4),\r\n      FORMAT_"
  "ASPECT_BYTE_SIZE(R8G8B8_SSCALED, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8_UINT, COLOR, 1),\r\n      FORMAT_ASPECT_B"
  "YTE_SIZE(R64G64_SFLOAT, COLOR, 16),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16_SINT, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZ"
  "E(R32G32B32A32_SINT, COLOR, 16),\r\n      FORMAT_ASPECT_BYTE_SIZE(R5G6B5_UNORM_PACK16, COLOR, 2),\r\n      FORMAT_ASPECT_"
  "BYTE_SIZE(B8G8R8A8_USCALED, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64B64_SINT, COLOR, 24),\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(B8G8R8A8_UNORM, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32G32B32_SINT, COLOR, 12),\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(B8G8R8_SNORM, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2B10G10R10_UINT_PACK32, COLOR, 4),\r\n      FORMAT"
  "_ASPECT_BYTE_SIZE(B5G5R5A1_UNORM_PACK16, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8B8_UINT, COLOR, 3),\r\n      FOR"
  "MAT_ASPECT_BYTE_SIZE(A2B10G10R10_SINT_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16_SFLOAT, COLOR, 2),\r\n     "
  " FORMAT_ASPECT_BYTE_SIZE(B4G4R4A4_UNORM_PACK16, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16_UNORM, COLOR, 4),\r\n "
  "     FORMAT_ASPECT_BYTE_SIZE(R64_SFLOAT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(B10G11R11_UFLOAT_PACK32, COLOR, 4),\r"
  "\n      FORMAT_ASPECT_BYTE_SIZE(R64G64B64A64_SFLOAT, COLOR, 32),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8_USCALED, COLOR, 2)"
  ",\r\n      FORMAT_ASPECT_BYTE_SIZE(R32G32B32_SFLOAT, COLOR, 12),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8_SINT, COLOR, 2),\r"
  "\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8_SINT, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32G32B32A32_SFLOAT, COLOR, 16),"
  "\r\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8_SSCALED, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2B10G10R10_UNORM_PACK32, C"
  "OLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32_SINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64B64A64_SINT, COLOR"
  ", 32),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16_SFLOAT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8_UNORM, COLOR, 3"
  "),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2R10G10B10_SSCALED_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8_SNORM, COL"
  "OR, 1),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_UINT_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_SSCAL"
  "ED_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64B64_SFLOAT, COLOR, 24),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G"
  "8_SRGB, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_SNORM, COLOR, 6),\r\n      FORMAT_ASPECT_BYTE_SIZE(B5G6R5_U"
  "NORM_PACK16, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16_UINT, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(R32G32_SIN"
  "T, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8A8_SSCALED, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16_SI"
  "NT, COLOR, 6),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_UNORM_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64"
  "B64_UINT, COLOR, 24),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16_SSCALED, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(A8B8G8R8_"
  "SRGB_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(B8G8R8A8_SNORM, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(A1R5"
  "G5B5_UNORM_PACK16, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SIZE(A2B10G10R10_SNORM_PACK32, COLOR, 4),\r\n      FORMAT_ASPEC"
  "T_BYTE_SIZE(R16G16_UINT, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(R8G8_UINT, COLOR, 2),\r\n      FORMAT_ASPECT_BYTE_SI"
  "ZE(R32G32_SFLOAT, COLOR, 8),\r\n      FORMAT_ASPECT_BYTE_SIZE(R64G64B64A64_UINT, COLOR, 32),\r\n      FORMAT_ASPECT_BYTE_"
  "SIZE(R8G8B8_UNORM, COLOR, 3),\r\n      FORMAT_ASPECT_BYTE_SIZE(R16G16B16A16_USCALED, COLOR, 8),\r\n      FORMAT_ASPECT_BY"
  "TE_SIZE(A2B10G10R10_USCALED_PACK32, COLOR, 4),\r\n      FORMAT_ASPECT_BYTE_SIZE(D32_SFLOAT, DEPTH, 4),\r\n      FORMAT_AS"
  "PECT_BYTE_SIZE(D16_UNORM, DEPTH, 2),\r\n      {VK_FORMAT_D16_UNORM_S8_UINT, std::pair<VkImageAspectFlags, uint32_t>(\r\n "
  "                                       VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT, 3)},\r\n      {VK_FORMAT_"
  "D24_UNORM_S8_UINT, std::pair<VkImageAspectFlags, uint32_t>(\r\n                                        VK_IMAGE_ASPECT_DE"
  "PTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT, 4)},\r\n      {VK_FORMAT_D32_SFLOAT_S8_UINT, std::pair<VkImageAspectFlags, uint32_"
  "t>(\r\n                                         VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT, 5)},\r\n  };\r\n"
  "  return kImageAspectsAndByteSize;\r\n}\r\n\r\nbool CheckFormatValid(VkFormat format)\r\n{\r\n  const std::map<VkFormat, "
  "std::pair<VkImageAspectFlags, uint32_t>> &map =\r\n      GetImageAspectsAndByteSize();\r\n  return map.find(format) != ma"
  "p.end();\r\n}\r\n\r\nVkImageAspectFlags GetImageAspect(VkFormat format)\r\n{\r\n  const std::map<VkFormat, std::pair<VkIm"
  "ageAspectFlags, uint32_t>> &map =\r\n      GetImageAspectsAndByteSize();\r\n  auto p = map.find(format);\r\n  return p !="
  " map.end() ? p->second.first : 0;\r\n}\r\n\r\nuint32_t GetImageByteSize(VkFormat format)\r\n{\r\n  const std::map<VkForma"
  "t, std::pair<VkImageAspectFlags, uint32_t>> &map =\r\n      GetImageAspectsAndByteSize();\r\n  auto p = map.find(format);"
  "\r\n  return p != map.end() ? p->second.second : 0;\r\n}\r\n\r\nstd::string FormatToString(VkFormat f)\r\n{\r\n#define RE"
  "TURN_VK_FORMAT_STRING(x) \\\r\n  case VK_FORMAT_##x: return STRINGIFY(x);\r\n\r\n  switch(f)\r\n  {\r\n    RETURN_VK_FORM"
  "AT_STRING(UNDEFINED);\r\n    RETURN_VK_FORMAT_STRING(R4G4_UNORM_PACK8);\r\n    RETURN_VK_FORMAT_STRING(R4G4B4A4_UNORM_PAC"
  "K16);\r\n    RETURN_VK_FORMAT_STRING(B4G4R4A4_UNORM_PACK16);\r\n    RETURN_VK_FORMAT_STRING(R5G6B5_UNORM_PACK16);\r\n    "
  "RETURN_VK_FORMAT_STRING(B5G6R5_UNORM_PACK16);\r\n    RETURN_VK_FORMAT_STRING(R5G5B5A1_UNORM_PACK16);\r\n    RETURN_VK_FOR"
  "MAT_STRING(B5G5R5A1_UNORM_PACK16);\r\n    RETURN_VK_FORMAT_STRING(A1R5G5B5_UNORM_PACK16);\r\n    RETURN_VK_FORMAT_STRING("
  "R8_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R8_SNORM);\r\n    RETURN_VK_FORMAT_STRING(R8_USCALED);\r\n    RETURN_VK_FORMAT_"
  "STRING(R8_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R8_UINT);\r\n    RETURN_VK_FORMAT_STRING(R8_SINT);\r\n    RETURN_VK_FO"
  "RMAT_STRING(R8_SRGB);\r\n    RETURN_VK_FORMAT_STRING(R8G8_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R8G8_SNORM);\r\n    RETU"
  "RN_VK_FORMAT_STRING(R8G8_USCALED);\r\n    RETURN_VK_FORMAT_STRING(R8G8_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R8G8_UINT"
  ");\r\n    RETURN_VK_FORMAT_STRING(R8G8_SINT);\r\n    RETURN_VK_FORMAT_STRING(R8G8_SRGB);\r\n    RETURN_VK_FORMAT_STRING(R"
  "8G8B8_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8_SNORM);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8_USCALED);\r\n    RETURN"
  "_VK_FORMAT_STRING(R8G8B8_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8_UINT);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8_SIN"
  "T);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8_SRGB);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8_UNORM);\r\n    RETURN_VK_FORMAT_ST"
  "RING(B8G8R8_SNORM);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8_USCALED);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8_SSCALED);\r\n  "
  "  RETURN_VK_FORMAT_STRING(B8G8R8_UINT);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8_SINT);\r\n    RETURN_VK_FORMAT_STRING(B8G8R"
  "8_SRGB);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8A8_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8A8_SNORM);\r\n    RETURN_VK"
  "_FORMAT_STRING(R8G8B8A8_USCALED);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8A8_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8"
  "A8_UINT);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8A8_SINT);\r\n    RETURN_VK_FORMAT_STRING(R8G8B8A8_SRGB);\r\n    RETURN_VK_"
  "FORMAT_STRING(B8G8R8A8_UNORM);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8A8_SNORM);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8A8_US"
  "CALED);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8A8_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8A8_UINT);\r\n    RETURN_VK"
  "_FORMAT_STRING(B8G8R8A8_SINT);\r\n    RETURN_VK_FORMAT_STRING(B8G8R8A8_SRGB);\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_UNO"
  "RM_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_SNORM_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_USCALED_PACK32"
  ");\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_SSCALED_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_UINT_PACK32);\r\n    "
  "RETURN_VK_FORMAT_STRING(A8B8G8R8_SINT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A8B8G8R8_SRGB_PACK32);\r\n    RETURN_VK_FOR"
  "MAT_STRING(A2R10G10B10_UNORM_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2R10G10B10_SNORM_PACK32);\r\n    RETURN_VK_FORMAT_S"
  "TRING(A2R10G10B10_USCALED_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2R10G10B10_SSCALED_PACK32);\r\n    RETURN_VK_FORMAT_ST"
  "RING(A2R10G10B10_UINT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2R10G10B10_SINT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2"
  "B10G10R10_UNORM_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2B10G10R10_SNORM_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2B10G1"
  "0R10_USCALED_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2B10G10R10_SSCALED_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2B10G10"
  "R10_UINT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(A2B10G10R10_SINT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(R16_UNORM);\r\n"
  "    RETURN_VK_FORMAT_STRING(R16_SNORM);\r\n    RETURN_VK_FORMAT_STRING(R16_USCALED);\r\n    RETURN_VK_FORMAT_STRING(R16_S"
  "SCALED);\r\n    RETURN_VK_FORMAT_STRING(R16_UINT);\r\n    RETURN_VK_FORMAT_STRING(R16_SINT);\r\n    RETURN_VK_FORMAT_STRI"
  "NG(R16_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R16G16_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R16G16_SNORM);\r\n    RETURN"
  "_VK_FORMAT_STRING(R16G16_USCALED);\r\n    RETURN_VK_FORMAT_STRING(R16G16_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R16G16_"
  "UINT);\r\n    RETURN_VK_FORMAT_STRING(R16G16_SINT);\r\n    RETURN_VK_FORMAT_STRING(R16G16_SFLOAT);\r\n    RETURN_VK_FORMA"
  "T_STRING(R16G16B16_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16_SNORM);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16_USCA"
  "LED);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16_UINT);\r\n    RETURN_VK"
  "_FORMAT_STRING(R16G16B16_SINT);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R16G16B1"
  "6A16_UNORM);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16A16_SNORM);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16A16_USCALED);\r\n"
  "    RETURN_VK_FORMAT_STRING(R16G16B16A16_SSCALED);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16A16_UINT);\r\n    RETURN_VK_FO"
  "RMAT_STRING(R16G16B16A16_SINT);\r\n    RETURN_VK_FORMAT_STRING(R16G16B16A16_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R32_U"
  "INT);\r\n    RETURN_VK_FORMAT_STRING(R32_SINT);\r\n    RETURN_VK_FORMAT_STRING(R32_SFLOAT);\r\n    RETURN_VK_FORMAT_STRIN"
  "G(R32G32_UINT);\r\n    RETURN_VK_FORMAT_STRING(R32G32_SINT);\r\n    RETURN_VK_FORMAT_STRING(R32G32_SFLOAT);\r\n    RETURN"
  "_VK_FORMAT_STRING(R32G32B32_UINT);\r\n    RETURN_VK_FORMAT_STRING(R32G32B32_SINT);\r\n    RETURN_VK_FORMAT_STRING(R32G32B"
  "32_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R32G32B32A32_UINT);\r\n    RETURN_VK_FORMAT_STRING(R32G32B32A32_SINT);\r\n    "
  "RETURN_VK_FORMAT_STRING(R32G32B32A32_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R64_UINT);\r\n    RETURN_VK_FORMAT_STRING(R6"
  "4_SINT);\r\n    RETURN_VK_FORMAT_STRING(R64_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R64G64_UINT);\r\n    RETURN_VK_FORMAT"
  "_STRING(R64G64_SINT);\r\n    RETURN_VK_FORMAT_STRING(R64G64_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(R64G64B64_UINT);\r\n "
  "   RETURN_VK_FORMAT_STRING(R64G64B64_SINT);\r\n    RETURN_VK_FORMAT_STRING(R64G64B64_SFLOAT);\r\n    RETURN_VK_FORMAT_STR"
  "ING(R64G64B64A64_UINT);\r\n    RETURN_VK_FORMAT_STRING(R64G64B64A64_SINT);\r\n    RETURN_VK_FORMAT_STRING(R64G64B64A64_SF"
  "LOAT);\r\n    RETURN_VK_FORMAT_STRING(B10G11R11_UFLOAT_PACK32);\r\n    RETURN_VK_FORMAT_STRING(E5B9G9R9_UFLOAT_PACK32);\r"
  "\n    RETURN_VK_FORMAT_STRING(D16_UNORM);\r\n    RETURN_VK_FORMAT_STRING(X8_D24_UNORM_PACK32);\r\n    RETURN_VK_FORMAT_ST"
  "RING(D32_SFLOAT);\r\n    RETURN_VK_FORMAT_STRING(S8_UINT);\r\n    RETURN_VK_FORMAT_STRING(D16_UNORM_S8_UINT);\r\n    RETU"
  "RN_VK_FORMAT_STRING(D24_UNORM_S8_UINT);\r\n    RETURN_VK_FORMAT_STRING(D32_SFLOAT_S8_UINT);\r\n    RETURN_VK_FORMAT_STRIN"
  "G(BC1_RGB_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC1_RGB_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC1_RGBA_UNORM"
  "_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC1_RGBA_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC2_UNORM_BLOCK);\r\n    RET"
  "URN_VK_FORMAT_STRING(BC2_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC3_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC3"
  "_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC4_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC4_SNORM_BLOCK);\r\n    RE"
  "TURN_VK_FORMAT_STRING(BC5_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC5_SNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(B"
  "C6H_UFLOAT_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC6H_SFLOAT_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(BC7_UNORM_BLOCK);\r\n"
  "    RETURN_VK_FORMAT_STRING(BC7_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ETC2_R8G8B8_UNORM_BLOCK);\r\n    RETURN_VK_FO"
  "RMAT_STRING(ETC2_R8G8B8_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ETC2_R8G8B8A1_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_S"
  "TRING(ETC2_R8G8B8A1_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ETC2_R8G8B8A8_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRIN"
  "G(ETC2_R8G8B8A8_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(EAC_R11_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(EAC_R11_"
  "SNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(EAC_R11G11_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(EAC_R11G11_SNORM_BLO"
  "CK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_4x4_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_4x4_SRGB_BLOCK);\r\n    RE"
  "TURN_VK_FORMAT_STRING(ASTC_5x4_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_5x4_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT"
  "_STRING(ASTC_5x5_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_5x5_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_6"
  "x5_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_6x5_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_6x6_UNORM_BLOCK"
  ");\r\n    RETURN_VK_FORMAT_STRING(ASTC_6x6_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_8x5_UNORM_BLOCK);\r\n    RETU"
  "RN_VK_FORMAT_STRING(ASTC_8x5_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_8x6_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_S"
  "TRING(ASTC_8x6_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_8x8_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_8x8"
  "_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x5_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x5_SRGB_BLOCK)"
  ";\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x6_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x6_SRGB_BLOCK);\r\n    RET"
  "URN_VK_FORMAT_STRING(ASTC_10x8_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x8_SRGB_BLOCK);\r\n    RETURN_VK_FORMA"
  "T_STRING(ASTC_10x10_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_10x10_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(A"
  "STC_12x10_UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_12x10_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_12x12_"
  "UNORM_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(ASTC_12x12_SRGB_BLOCK);\r\n    RETURN_VK_FORMAT_STRING(G8B8G8R8_422_UNORM);\r"
  "\n    RETURN_VK_FORMAT_STRING(B8G8R8G8_422_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G8_B8_R8_3PLANE_420_UNORM);\r\n    RETU"
  "RN_VK_FORMAT_STRING(G8_B8R8_2PLANE_420_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G8_B8_R8_3PLANE_422_UNORM);\r\n    RETURN_V"
  "K_FORMAT_STRING(G8_B8R8_2PLANE_422_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G8_B8_R8_3PLANE_444_UNORM);\r\n    RETURN_VK_FO"
  "RMAT_STRING(R10X6_UNORM_PACK16);\r\n    RETURN_VK_FORMAT_STRING(R10X6G10X6_UNORM_2PACK16);\r\n    RETURN_VK_FORMAT_STRING"
  "(R10X6G10X6B10X6A10X6_UNORM_4PACK16);\r\n    RETURN_VK_FORMAT_STRING(G10X6B10X6G10X6R10X6_422_UNORM_4PACK16);\r\n    RETU"
  "RN_VK_FORMAT_STRING(B10X6G10X6R10X6G10X6_422_UNORM_4PACK16);\r\n    RETURN_VK_FORMAT_STRING(G10X6_B10X6_R10X6_3PLANE_420_"
  "UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING"
  "(G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16);\r"
  "\n    RETURN_VK_FORMAT_STRING(G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(R12X4_UNORM_PAC"
  "K16);\r\n    RETURN_VK_FORMAT_STRING(R12X4G12X4_UNORM_2PACK16);\r\n    RETURN_VK_FORMAT_STRING(R12X4G12X4B12X4A12X4_UNORM"
  "_4PACK16);\r\n    RETURN_VK_FORMAT_STRING(G12X4B12X4G12X4R12X4_422_UNORM_4PACK16);\r\n    RETURN_VK_FORMAT_STRING(B12X4G1"
  "2X4R12X4G12X4_422_UNORM_4PACK16);\r\n    RETURN_VK_FORMAT_STRING(G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16);\r\n    RETU"
  "RN_VK_FORMAT_STRING(G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(G12X4_B12X4_R12X4_3PLANE_4"
  "22_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STR"
  "ING(G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16);\r\n    RETURN_VK_FORMAT_STRING(G16B16G16R16_422_UNORM);\r\n    RETURN_VK"
  "_FORMAT_STRING(B16G16R16G16_422_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G16_B16_R16_3PLANE_420_UNORM);\r\n    RETURN_VK_FO"
  "RMAT_STRING(G16_B16R16_2PLANE_420_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G16_B16_R16_3PLANE_422_UNORM);\r\n    RETURN_VK_"
  "FORMAT_STRING(G16_B16R16_2PLANE_422_UNORM);\r\n    RETURN_VK_FORMAT_STRING(G16_B16_R16_3PLANE_444_UNORM);\r\n    RETURN_V"
  "K_FORMAT_STRING(PVRTC1_2BPP_UNORM_BLOCK_IMG);\r\n    RETURN_VK_FORMAT_STRING(PVRTC1_4BPP_UNORM_BLOCK_IMG);\r\n    RETURN_"
  "VK_FORMAT_STRING(PVRTC2_2BPP_UNORM_BLOCK_IMG);\r\n    RETURN_VK_FORMAT_STRING(PVRTC2_4BPP_UNORM_BLOCK_IMG);\r\n    RETURN"
  "_VK_FORMAT_STRING(PVRTC1_2BPP_SRGB_BLOCK_IMG);\r\n    RETURN_VK_FORMAT_STRING(PVRTC1_4BPP_SRGB_BLOCK_IMG);\r\n    RETURN_"
  "VK_FORMAT_STRING(PVRTC2_2BPP_SRGB_BLOCK_IMG);\r\n    RETURN_VK_FORMAT_STRING(PVRTC2_4BPP_SRGB_BLOCK_IMG);\r\n\r\n    defa"
  "ult: assert(0);\r\n  }\r\n\r\n  return \"ERROR\";\r\n}\r\n\r\nuint32_t FixCompressedSizes(VkFormat fmt, VkExtent3D &dim, "
  "uint32_t &offset)\r\n{\r\n  switch(fmt)\r\n  {\r\n    case VK_FORMAT_BC1_RGB_UNORM_BLOCK:\r\n    case VK_FORMAT_BC1_RGBA_"
  "UNORM_BLOCK:\r\n    case VK_FORMAT_BC1_RGB_SRGB_BLOCK:\r\n    case VK_FORMAT_BC1_RGBA_SRGB_BLOCK:\r\n    case VK_FORMAT_B"
  "C2_SRGB_BLOCK:\r\n    case VK_FORMAT_BC2_UNORM_BLOCK:\r\n    case VK_FORMAT_BC3_SRGB_BLOCK:\r\n    case VK_FORMAT_BC3_UNO"
  "RM_BLOCK:\r\n    case VK_FORMAT_BC4_SNORM_BLOCK:\r\n    case VK_FORMAT_BC4_UNORM_BLOCK:\r\n    case VK_FORMAT_BC5_SNORM_B"
  "LOCK:\r\n    case VK_FORMAT_BC5_UNORM_BLOCK:\r\n    case VK_FORMAT_BC6H_SFLOAT_BLOCK:\r\n    case VK_FORMAT_BC6H_UFLOAT_B"
  "LOCK:\r\n    case VK_FORMAT_BC7_SRGB_BLOCK:\r\n    case VK_FORMAT_BC7_UNORM_BLOCK:\r\n      dim.width = (uint32_t)Aligned"
  "Size(dim.width, 4);\r\n      dim.height = (uint32_t)AlignedSize(dim.height, 4);\r\n      dim.depth = (uint32_t)AlignedSiz"
  "e(dim.depth, 1);\r\n      offset = (uint32_t)AlignedSize(offset, 4);\r\n      return 1;\r\n\r\n    default: break;\r\n  }"
  "\r\n\r\n  offset = (uint32_t)AlignedSize(offset, 4);\r\n  return 0;\r\n}\r\n\r\nVkImageAspectFlags FullAspectFromFormat(V"
  "kFormat fmt)\r\n{\r\n  if(fmt == VK_FORMAT_D16_UNORM || fmt == VK_FORMAT_D32_SFLOAT)\r\n    return VK_IMAGE_ASPECT_DEPTH_"
  "BIT;\r\n  else if(fmt == VK_FORMAT_D16_UNORM_S8_UINT || fmt == VK_FORMAT_D24_UNORM_S8_UINT ||\r\n          fmt == VK_FORM"
  "AT_D32_SFLOAT_S8_UINT)\r\n    return VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT;\r\n  else    //  TODO(akhar"
  "lamov): this is actually incorrect but OK for now\r\n    return VK_IMAGE_ASPECT_COLOR_BIT;\r\n}\r\n\r\nVkImageAspectFlags"
  " AspectFromFormat(VkFormat fmt)\r\n{\r\n  if(fmt == VK_FORMAT_D16_UNORM || fmt == VK_FORMAT_D32_SFLOAT || fmt == VK_FORMA"
  "T_D16_UNORM_S8_UINT ||\r\n     fmt == VK_FORMAT_D24_UNORM_S8_UINT || fmt == VK_FORMAT_D32_SFLOAT_S8_UINT)\r\n    return V"
  "K_IMAGE_ASPECT_DEPTH_BIT;\r\n  else\r\n    return VK_IMAGE_ASPECT_COLOR_BIT;\r\n}\r\ndouble SizeOfFormat(VkFormat fmt, Vk"
  "ImageAspectFlagBits aspect)\r\n{\r\n  if(aspect == VK_IMAGE_ASPECT_STENCIL_BIT)\r\n  {\r\n    switch(fmt)\r\n    {\r\n   "
  "   case VK_FORMAT_D32_SFLOAT_S8_UINT:\r\n      case VK_FORMAT_D24_UNORM_S8_UINT:\r\n      case VK_FORMAT_D16_UNORM_S8_UIN"
  "T: return 1.0;\r\n      default: assert(0);\r\n    }\r\n  }\r\n  else if(aspect == VK_IMAGE_ASPECT_COLOR_BIT || aspect =="
  " VK_IMAGE_ASPECT_DEPTH_BIT)\r\n  {\r\n    switch(fmt)\r\n    {\r\n      case VK_FORMAT_R4G4_UNORM_PACK8:\r\n      case VK"
  "_FORMAT_R8_UNORM:\r\n      case VK_FORMAT_R8_SNORM:\r\n      case VK_FORMAT_R8_USCALED:\r\n      case VK_FORMAT_R8_SSCALE"
  "D:\r\n      case VK_FORMAT_R8_UINT:\r\n      case VK_FORMAT_R8_SINT:\r\n      case VK_FORMAT_R8_SRGB: return 1.0;\r\n\r\n"
  "      case VK_FORMAT_R4G4B4A4_UNORM_PACK16:\r\n      case VK_FORMAT_B4G4R4A4_UNORM_PACK16:\r\n      case VK_FORMAT_R5G6B5"
  "_UNORM_PACK16:\r\n      case VK_FORMAT_B5G6R5_UNORM_PACK16:\r\n      case VK_FORMAT_R5G5B5A1_UNORM_PACK16:\r\n      case "
  "VK_FORMAT_B5G5R5A1_UNORM_PACK16:\r\n      case VK_FORMAT_A1R5G5B5_UNORM_PACK16:\r\n      case VK_FORMAT_R8G8_UNORM:\r\n  "
  "    case VK_FORMAT_R8G8_SNORM:\r\n      case VK_FORMAT_R8G8_USCALED:\r\n      case VK_FORMAT_R8G8_SSCALED:\r\n      case "
  "VK_FORMAT_R8G8_UINT:\r\n      case VK_FORMAT_R8G8_SINT:\r\n      case VK_FORMAT_R8G8_SRGB:\r\n      case VK_FORMAT_R16_UN"
  "ORM:\r\n      case VK_FORMAT_R16_SNORM:\r\n      case VK_FORMAT_R16_USCALED:\r\n      case VK_FORMAT_R16_SSCALED:\r\n    "
  "  case VK_FORMAT_R16_UINT:\r\n      case VK_FORMAT_R16_SINT:\r\n      case VK_FORMAT_R16_SFLOAT:\r\n      case VK_FORMAT_"
  "D16_UNORM:\r\n      case VK_FORMAT_D16_UNORM_S8_UINT: return 2.0;\r\n\r\n      case VK_FORMAT_R8G8B8_UNORM:\r\n      case"
  " VK_FORMAT_R8G8B8_SNORM:\r\n      case VK_FORMAT_R8G8B8_USCALED:\r\n      case VK_FORMAT_R8G8B8_SSCALED:\r\n      case VK"
  "_FORMAT_R8G8B8_UINT:\r\n      case VK_FORMAT_R8G8B8_SINT:\r\n      case VK_FORMAT_R8G8B8_SRGB:\r\n      case VK_FORMAT_B8"
  "G8R8_UNORM:\r\n      case VK_FORMAT_B8G8R8_SNORM:\r\n      case VK_FORMAT_B8G8R8_USCALED:\r\n      case VK_FORMAT_B8G8R8_"
  "SSCALED:\r\n      case VK_FORMAT_B8G8R8_UINT:\r\n      case VK_FORMAT_B8G8R8_SINT:\r\n      case VK_FORMAT_B8G8R8_SRGB:\r"
  "\n      case VK_FORMAT_D24_UNORM_S8_UINT: return 3.0;\r\n\r\n      case VK_FORMAT_R8G8B8A8_UNORM:\r\n      case VK_FORMAT"
  "_R8G8B8A8_SNORM:\r\n      case VK_FORMAT_R8G8B8A8_USCALED:\r\n      case VK_FORMAT_R8G8B8A8_SSCALED:\r\n      case VK_FOR"
  "MAT_R8G8B8A8_UINT:\r\n      case VK_FORMAT_R8G8B8A8_SINT:\r\n      case VK_FORMAT_R8G8B8A8_SRGB:\r\n      case VK_FORMAT_"
  "B8G8R8A8_UNORM:\r\n      case VK_FORMAT_B8G8R8A8_SNORM:\r\n      case VK_FORMAT_B8G8R8A8_USCALED:\r\n      case VK_FORMAT"
  "_B8G8R8A8_SSCALED:\r\n      case VK_FORMAT_B8G8R8A8_UINT:\r\n      case VK_FORMAT_B8G8R8A8_SINT:\r\n      case VK_FORMAT_"
  "B8G8R8A8_SRGB:\r\n      case VK_FORMAT_A8B8G8R8_UNORM_PACK32:\r\n      case VK_FORMAT_A8B8G8R8_SNORM_PACK32:\r\n      cas"
  "e VK_FORMAT_A8B8G8R8_USCALED_PACK32:\r\n      case VK_FORMAT_A8B8G8R8_SSCALED_PACK32:\r\n      case VK_FORMAT_A8B8G8R8_UI"
  "NT_PACK32:\r\n      case VK_FORMAT_A8B8G8R8_SINT_PACK32:\r\n      case VK_FORMAT_A8B8G8R8_SRGB_PACK32:\r\n      case VK_F"
  "ORMAT_A2R10G10B10_UNORM_PACK32:\r\n      case VK_FORMAT_A2R10G10B10_SNORM_PACK32:\r\n      case VK_FORMAT_A2R10G10B10_USC"
  "ALED_PACK32:\r\n      case VK_FORMAT_A2R10G10B10_SSCALED_PACK32:\r\n      case VK_FORMAT_A2R10G10B10_UINT_PACK32:\r\n    "
  "  case VK_FORMAT_A2R10G10B10_SINT_PACK32:\r\n      case VK_FORMAT_A2B10G10R10_UNORM_PACK32:\r\n      case VK_FORMAT_A2B10"
  "G10R10_SNORM_PACK32:\r\n      case VK_FORMAT_A2B10G10R10_USCALED_PACK32:\r\n      case VK_FORMAT_A2B10G10R10_SSCALED_PACK"
  "32:\r\n      case VK_FORMAT_A2B10G10R10_UINT_PACK32:\r\n      case VK_FORMAT_A2B10G10R10_SINT_PACK32:\r\n      case VK_FO"
  "RMAT_R16G16_UNORM:\r\n      case VK_FORMAT_R16G16_SNORM:\r\n      case VK_FORMAT_R16G16_USCALED:\r\n      case VK_FORMAT_"
  "R16G16_SSCALED:\r\n      case VK_FORMAT_R16G16_UINT:\r\n      case VK_FORMAT_R16G16_SINT:\r\n      case VK_FORMAT_R16G16_"
  "SFLOAT:\r\n      case VK_FORMAT_R32_UINT:\r\n      case VK_FORMAT_R32_SINT:\r\n      case VK_FORMAT_R32_SFLOAT:\r\n      "
  "case VK_FORMAT_B10G11R11_UFLOAT_PACK32:\r\n      case VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:\r\n      case VK_FORMAT_D32_SFLOA"
  "T:\r\n      case VK_FORMAT_D32_SFLOAT_S8_UINT: return 4.0;\r\n\r\n      case VK_FORMAT_R16G16B16_UNORM:\r\n      case VK_"
  "FORMAT_R16G16B16_SNORM:\r\n      case VK_FORMAT_R16G16B16_USCALED:\r\n      case VK_FORMAT_R16G16B16_SSCALED:\r\n      ca"
  "se VK_FORMAT_R16G16B16_UINT:\r\n      case VK_FORMAT_R16G16B16_SINT:\r\n      case VK_FORMAT_R16G16B16_SFLOAT: return 6.0"
  "f;\r\n\r\n      case VK_FORMAT_R16G16B16A16_UNORM:\r\n      case VK_FORMAT_R16G16B16A16_SNORM:\r\n      case VK_FORMAT_R1"
  "6G16B16A16_USCALED:\r\n      case VK_FORMAT_R16G16B16A16_SSCALED:\r\n      case VK_FORMAT_R16G16B16A16_UINT:\r\n      cas"
  "e VK_FORMAT_R16G16B16A16_SINT:\r\n      case VK_FORMAT_R16G16B16A16_SFLOAT:\r\n      case VK_FORMAT_R32G32_UINT:\r\n     "
  " case VK_FORMAT_R32G32_SINT:\r\n      case VK_FORMAT_R32G32_SFLOAT:\r\n      case VK_FORMAT_R64_UINT:\r\n      case VK_FO"
  "RMAT_R64_SINT:\r\n      case VK_FORMAT_R64_SFLOAT: return 8.0;\r\n\r\n      case VK_FORMAT_R32G32B32_UINT:\r\n      case "
  "VK_FORMAT_R32G32B32_SINT:\r\n      case VK_FORMAT_R32G32B32_SFLOAT: return 12.0;\r\n\r\n      case VK_FORMAT_R32G32B32A32"
  "_UINT:\r\n      case VK_FORMAT_R32G32B32A32_SINT:\r\n      case VK_FORMAT_R32G32B32A32_SFLOAT:\r\n      case VK_FORMAT_R6"
  "4G64_UINT:\r\n      case VK_FORMAT_R64G64_SINT:\r\n      case VK_FORMAT_R64G64_SFLOAT: return 16.0;\r\n\r\n      case VK_"
  "FORMAT_R64G64B64_UINT:\r\n      case VK_FORMAT_R64G64B64_SINT:\r\n      case VK_FORMAT_R64G64B64_SFLOAT: return 24.0;\r\n"
  "\r\n      case VK_FORMAT_R64G64B64A64_UINT:\r\n      case VK_FORMAT_R64G64B64A64_SINT:\r\n      case VK_FORMAT_R64G64B64A"
  "64_SFLOAT: return 32.0;\r\n\r\n      case VK_FORMAT_BC2_SRGB_BLOCK:\r\n      case VK_FORMAT_BC2_UNORM_BLOCK:\r\n      cas"
  "e VK_FORMAT_BC3_SRGB_BLOCK:\r\n      case VK_FORMAT_BC3_UNORM_BLOCK:\r\n      case VK_FORMAT_BC5_SNORM_BLOCK:\r\n      ca"
  "se VK_FORMAT_BC5_UNORM_BLOCK:\r\n      case VK_FORMAT_BC6H_SFLOAT_BLOCK:\r\n      case VK_FORMAT_BC6H_UFLOAT_BLOCK:\r\n  "
  "    case VK_FORMAT_BC7_SRGB_BLOCK:\r\n      case VK_FORMAT_BC7_UNORM_BLOCK: return 1.0;\r\n\r\n      case VK_FORMAT_BC1_R"
  "GB_UNORM_BLOCK:\r\n      case VK_FORMAT_BC1_RGBA_UNORM_BLOCK:\r\n      case VK_FORMAT_BC1_RGB_SRGB_BLOCK:\r\n      case V"
  "K_FORMAT_BC1_RGBA_SRGB_BLOCK:\r\n      case VK_FORMAT_BC4_SNORM_BLOCK:\r\n      case VK_FORMAT_BC4_UNORM_BLOCK: return 0."
  "5;\r\n\r\n      default: assert(0);\r\n    }\r\n  }\r\n  return 0.0;\r\n}\r\n\r\nuint32_t ChannelsInFormat(VkFormat fmt)\r"
  "\n{\r\n  switch(fmt)\r\n  {\r\n    case VK_FORMAT_R8_UNORM:\r\n    case VK_FORMAT_R8_SNORM:\r\n    case VK_FORMAT_R8_USCA"
  "LED:\r\n    case VK_FORMAT_R8_SSCALED:\r\n    case VK_FORMAT_R8_UINT:\r\n    case VK_FORMAT_R8_SINT:\r\n    case VK_FORMA"
  "T_R8_SRGB:\r\n    case VK_FORMAT_R16_UNORM:\r\n    case VK_FORMAT_R16_SNORM:\r\n    case VK_FORMAT_R16_USCALED:\r\n    ca"
  "se VK_FORMAT_R16_SSCALED:\r\n    case VK_FORMAT_R16_UINT:\r\n    case VK_FORMAT_R16_SINT:\r\n    case VK_FORMAT_R16_SFLOA"
  "T:\r\n    case VK_FORMAT_D16_UNORM:\r\n    case VK_FORMAT_D16_UNORM_S8_UINT:\r\n    case VK_FORMAT_D24_UNORM_S8_UINT:\r\n"
  "    case VK_FORMAT_R32_UINT:\r\n    case VK_FORMAT_R32_SINT:\r\n    case VK_FORMAT_R32_SFLOAT:\r\n    case VK_FORMAT_D32_"
  "SFLOAT:\r\n    case VK_FORMAT_D32_SFLOAT_S8_UINT:\r\n    case VK_FORMAT_R64_UINT:\r\n    case VK_FORMAT_R64_SINT:\r\n    "
  "case VK_FORMAT_R64_SFLOAT: return 1;\r\n\r\n    case VK_FORMAT_R4G4_UNORM_PACK8:\r\n    case VK_FORMAT_R8G8_UNORM:\r\n   "
  " case VK_FORMAT_R8G8_SNORM:\r\n    case VK_FORMAT_R8G8_USCALED:\r\n    case VK_FORMAT_R8G8_SSCALED:\r\n    case VK_FORMAT"
  "_R8G8_UINT:\r\n    case VK_FORMAT_R8G8_SINT:\r\n    case VK_FORMAT_R8G8_SRGB:\r\n    case VK_FORMAT_R16G16_UNORM:\r\n    "
  "case VK_FORMAT_R16G16_SNORM:\r\n    case VK_FORMAT_R16G16_USCALED:\r\n    case VK_FORMAT_R16G16_SSCALED:\r\n    case VK_F"
  "ORMAT_R16G16_UINT:\r\n    case VK_FORMAT_R16G16_SINT:\r\n    case VK_FORMAT_R16G16_SFLOAT:\r\n    case VK_FORMAT_R32G32_U"
  "INT:\r\n    case VK_FORMAT_R32G32_SINT:\r\n    case VK_FORMAT_R32G32_SFLOAT:\r\n    case VK_FORMAT_R64G64_UINT:\r\n    ca"
  "se VK_FORMAT_R64G64_SINT:\r\n    case VK_FORMAT_R64G64_SFLOAT: return 2;\r\n\r\n    case VK_FORMAT_R5G6B5_UNORM_PACK16:\r"
  "\n    case VK_FORMAT_B5G6R5_UNORM_PACK16:\r\n    case VK_FORMAT_R8G8B8_UNORM:\r\n    case VK_FORMAT_R8G8B8_SNORM:\r\n    "
  "case VK_FORMAT_R8G8B8_USCALED:\r\n    case VK_FORMAT_R8G8B8_SSCALED:\r\n    case VK_FORMAT_R8G8B8_UINT:\r\n    case VK_FO"
  "RMAT_R8G8B8_SINT:\r\n    case VK_FORMAT_R8G8B8_SRGB:\r\n    case VK_FORMAT_B8G8R8_UNORM:\r\n    case VK_FORMAT_B8G8R8_SNO"
  "RM:\r\n    case VK_FORMAT_B8G8R8_USCALED:\r\n    case VK_FORMAT_B8G8R8_SSCALED:\r\n    case VK_FORMAT_B8G8R8_UINT:\r\n   "
  " case VK_FORMAT_B8G8R8_SINT:\r\n    case VK_FORMAT_B8G8R8_SRGB:\r\n    case VK_FORMAT_B10G11R11_UFLOAT_PACK32:\r\n    cas"
  "e VK_FORMAT_R16G16B16_UNORM:\r\n    case VK_FORMAT_R16G16B16_SNORM:\r\n    case VK_FORMAT_R16G16B16_USCALED:\r\n    case "
  "VK_FORMAT_R16G16B16_SSCALED:\r\n    case VK_FORMAT_R16G16B16_UINT:\r\n    case VK_FORMAT_R16G16B16_SINT:\r\n    case VK_F"
  "ORMAT_R16G16B16_SFLOAT:\r\n    case VK_FORMAT_R32G32B32_UINT:\r\n    case VK_FORMAT_R32G32B32_SINT:\r\n    case VK_FORMAT"
  "_R32G32B32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64_UINT:\r\n    case VK_FORMAT_R64G64B64_SINT:\r\n    case VK_FORMAT_R64G"
  "64B64_SFLOAT: return 3;\r\n\r\n    case VK_FORMAT_R4G4B4A4_UNORM_PACK16:\r\n    case VK_FORMAT_B4G4R4A4_UNORM_PACK16:\r\n"
  "    case VK_FORMAT_R5G5B5A1_UNORM_PACK16:\r\n    case VK_FORMAT_B5G5R5A1_UNORM_PACK16:\r\n    case VK_FORMAT_A1R5G5B5_UNO"
  "RM_PACK16:\r\n    case VK_FORMAT_R8G8B8A8_UNORM:\r\n    case VK_FORMAT_R8G8B8A8_SNORM:\r\n    case VK_FORMAT_R8G8B8A8_USC"
  "ALED:\r\n    case VK_FORMAT_R8G8B8A8_SSCALED:\r\n    case VK_FORMAT_R8G8B8A8_UINT:\r\n    case VK_FORMAT_R8G8B8A8_SINT:\r"
  "\n    case VK_FORMAT_R8G8B8A8_SRGB:\r\n    case VK_FORMAT_B8G8R8A8_UNORM:\r\n    case VK_FORMAT_B8G8R8A8_SNORM:\r\n    ca"
  "se VK_FORMAT_B8G8R8A8_USCALED:\r\n    case VK_FORMAT_B8G8R8A8_SSCALED:\r\n    case VK_FORMAT_B8G8R8A8_UINT:\r\n    case V"
  "K_FORMAT_B8G8R8A8_SINT:\r\n    case VK_FORMAT_B8G8R8A8_SRGB:\r\n    case VK_FORMAT_A8B8G8R8_UNORM_PACK32:\r\n    case VK_"
  "FORMAT_A8B8G8R8_SNORM_PACK32:\r\n    case VK_FORMAT_A8B8G8R8_USCALED_PACK32:\r\n    case VK_FORMAT_A8B8G8R8_SSCALED_PACK3"
  "2:\r\n    case VK_FORMAT_A8B8G8R8_UINT_PACK32:\r\n    case VK_FORMAT_A8B8G8R8_SINT_PACK32:\r\n    case VK_FORMAT_A8B8G8R8"
  "_SRGB_PACK32:\r\n    case VK_FORMAT_A2R10G10B10_UNORM_PACK32:\r\n    case VK_FORMAT_A2R10G10B10_SNORM_PACK32:\r\n    case"
  " VK_FORMAT_A2R10G10B10_USCALED_PACK32:\r\n    case VK_FORMAT_A2R10G10B10_SSCALED_PACK32:\r\n    case VK_FORMAT_A2R10G10B1"
  "0_UINT_PACK32:\r\n    case VK_FORMAT_A2R10G10B10_SINT_PACK32:\r\n    case VK_FORMAT_A2B10G10R10_UNORM_PACK32:\r\n    case"
  " VK_FORMAT_A2B10G10R10_SNORM_PACK32:\r\n    case VK_FORMAT_A2B10G10R10_USCALED_PACK32:\r\n    case VK_FORMAT_A2B10G10R10_"
  "SSCALED_PACK32:\r\n    case VK_FORMAT_A2B10G10R10_UINT_PACK32:\r\n    case VK_FORMAT_A2B10G10R10_SINT_PACK32:\r\n    case"
  " VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:\r\n    case VK_FORMAT_R16G16B16A16_UNORM:\r\n    case VK_FORMAT_R16G16B16A16_SNORM:\r\n"
  "    case VK_FORMAT_R16G16B16A16_USCALED:\r\n    case VK_FORMAT_R16G16B16A16_SSCALED:\r\n    case VK_FORMAT_R16G16B16A16_U"
  "INT:\r\n    case VK_FORMAT_R16G16B16A16_SINT:\r\n    case VK_FORMAT_R16G16B16A16_SFLOAT:\r\n    case VK_FORMAT_R32G32B32A"
  "32_UINT:\r\n    case VK_FORMAT_R32G32B32A32_SINT:\r\n    case VK_FORMAT_R32G32B32A32_SFLOAT:\r\n    case VK_FORMAT_R64G64"
  "B64A64_UINT:\r\n    case VK_FORMAT_R64G64B64A64_SINT:\r\n    case VK_FORMAT_R64G64B64A64_SFLOAT: return 4;\r\n\r\n    def"
  "ault: assert(0);\r\n  }\r\n  return 0;\r\n}\r\n\r\nbool isHDRFormat(VkFormat fmt)\r\n{\r\n  switch(fmt)\r\n  {\r\n    cas"
  "e VK_FORMAT_R16_UINT:\r\n    case VK_FORMAT_R16_SINT:\r\n    case VK_FORMAT_R16_SFLOAT:\r\n    case VK_FORMAT_D16_UNORM:\r"
  "\n    case VK_FORMAT_D16_UNORM_S8_UINT:\r\n    case VK_FORMAT_D24_UNORM_S8_UINT:\r\n    case VK_FORMAT_R32_UINT:\r\n    c"
  "ase VK_FORMAT_R32_SINT:\r\n    case VK_FORMAT_R32_SFLOAT:\r\n    case VK_FORMAT_D32_SFLOAT:\r\n    case VK_FORMAT_D32_SFL"
  "OAT_S8_UINT:\r\n    case VK_FORMAT_R64_UINT:\r\n    case VK_FORMAT_R64_SINT:\r\n    case VK_FORMAT_R64_SFLOAT:\r\n    cas"
  "e VK_FORMAT_R16G16_UINT:\r\n    case VK_FORMAT_R16G16_SINT:\r\n    case VK_FORMAT_R16G16_SFLOAT:\r\n    case VK_FORMAT_R3"
  "2G32_UINT:\r\n    case VK_FORMAT_R32G32_SINT:\r\n    case VK_FORMAT_R32G32_SFLOAT:\r\n    case VK_FORMAT_R64G64_UINT:\r\n"
  "    case VK_FORMAT_R64G64_SINT:\r\n    case VK_FORMAT_R64G64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16_UINT:\r\n    case VK"
  "_FORMAT_R16G16B16_SINT:\r\n    case VK_FORMAT_R16G16B16_SFLOAT:\r\n    case VK_FORMAT_R32G32B32_UINT:\r\n    case VK_FORM"
  "AT_R32G32B32_SINT:\r\n    case VK_FORMAT_R32G32B32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64_UINT:\r\n    case VK_FORMAT_R6"
  "4G64B64_SINT:\r\n    case VK_FORMAT_R64G64B64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16A16_UINT:\r\n    case VK_FORMAT_R16G"
  "16B16A16_SINT:\r\n    case VK_FORMAT_R16G16B16A16_SFLOAT:\r\n    case VK_FORMAT_R32G32B32A32_UINT:\r\n    case VK_FORMAT_"
  "R32G32B32A32_SINT:\r\n    case VK_FORMAT_R32G32B32A32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64A64_UINT:\r\n    case VK_FOR"
  "MAT_R64G64B64A64_SINT:\r\n    case VK_FORMAT_R64G64B64A64_SFLOAT: return true;\r\n\r\n    default: return false;\r\n  }\r"
  "\n  return false;\r\n}\r\n\r\nuint32_t BitsPerChannelInFormat(VkFormat fmt, VkImageAspectFlagBits aspect)\r\n{\r\n  retur"
  "n static_cast<uint32_t>(SizeOfFormat(fmt, aspect) * 8 / ChannelsInFormat(fmt));\r\n}\r\n\r\nbool IsFPFormat(VkFormat fmt)"
  "\r\n{\r\n  switch(fmt)\r\n  {\r\n    case VK_FORMAT_R16_SFLOAT:\r\n    case VK_FORMAT_R32_SFLOAT:\r\n    case VK_FORMAT_D"
  "32_SFLOAT:\r\n    case VK_FORMAT_D32_SFLOAT_S8_UINT:\r\n    case VK_FORMAT_R64_SFLOAT:\r\n    case VK_FORMAT_R16G16_SFLOA"
  "T:\r\n    case VK_FORMAT_R32G32_SFLOAT:\r\n    case VK_FORMAT_R64G64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16_SFLOAT:\r\n "
  "   case VK_FORMAT_R32G32B32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16A16_SFLOAT:\r\n"
  "    case VK_FORMAT_R32G32B32A32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64A64_SFLOAT: return true;\r\n    default: return fa"
  "lse;\r\n  }\r\n  return false;\r\n}\r\n\r\nbool IsSignedFormat(VkFormat fmt)\r\n{\r\n  switch(fmt)\r\n  {\r\n    case VK_"
  "FORMAT_R8_SNORM:\r\n    case VK_FORMAT_R8_SSCALED:\r\n    case VK_FORMAT_R8_SINT:\r\n    case VK_FORMAT_R8G8_SNORM:\r\n  "
  "  case VK_FORMAT_R8G8_SSCALED:\r\n    case VK_FORMAT_R8G8_SINT:\r\n    case VK_FORMAT_R8G8B8_SNORM:\r\n    case VK_FORMAT"
  "_R8G8B8_SSCALED:\r\n    case VK_FORMAT_R8G8B8_SINT:\r\n    case VK_FORMAT_R8G8B8A8_SNORM:\r\n    case VK_FORMAT_R8G8B8A8_"
  "SSCALED:\r\n    case VK_FORMAT_R8G8B8A8_SINT:\r\n    case VK_FORMAT_B8G8R8_SNORM:\r\n    case VK_FORMAT_B8G8R8_SSCALED:\r"
  "\n    case VK_FORMAT_B8G8R8_SINT:\r\n    case VK_FORMAT_B8G8R8A8_SNORM:\r\n    case VK_FORMAT_B8G8R8A8_SSCALED:\r\n    ca"
  "se VK_FORMAT_B8G8R8A8_SINT:\r\n    case VK_FORMAT_R16_SINT:\r\n    case VK_FORMAT_R16_SFLOAT:\r\n    case VK_FORMAT_R32_S"
  "INT:\r\n    case VK_FORMAT_R32_SFLOAT:\r\n    case VK_FORMAT_D32_SFLOAT:\r\n    case VK_FORMAT_D32_SFLOAT_S8_UINT:\r\n   "
  " case VK_FORMAT_R64_SINT:\r\n    case VK_FORMAT_R64_SFLOAT:\r\n    case VK_FORMAT_R16G16_SINT:\r\n    case VK_FORMAT_R16G"
  "16_SFLOAT:\r\n    case VK_FORMAT_R32G32_SINT:\r\n    case VK_FORMAT_R32G32_SFLOAT:\r\n    case VK_FORMAT_R64G64_SINT:\r\n"
  "    case VK_FORMAT_R64G64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16_SINT:\r\n    case VK_FORMAT_R16G16B16_SFLOAT:\r\n    ca"
  "se VK_FORMAT_R32G32B32_SINT:\r\n    case VK_FORMAT_R32G32B32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64_SINT:\r\n    case VK"
  "_FORMAT_R64G64B64_SFLOAT:\r\n    case VK_FORMAT_R16G16B16A16_SINT:\r\n    case VK_FORMAT_R16G16B16A16_SFLOAT:\r\n    case"
  " VK_FORMAT_R32G32B32A32_SINT:\r\n    case VK_FORMAT_R32G32B32A32_SFLOAT:\r\n    case VK_FORMAT_R64G64B64A64_SINT:\r\n    "
  "case VK_FORMAT_R64G64B64A64_SFLOAT: return true;\r\n    default: return false;\r\n  }\r\n  return false;\r\n}\r\n\r\nuint"
  "32_t MinDimensionSize(VkFormat format)\r\n{\r\n  switch(format)\r\n  {\r\n    case VK_FORMAT_BC1_RGB_UNORM_BLOCK:\r\n    "
  "case VK_FORMAT_BC1_RGBA_UNORM_BLOCK:\r\n    case VK_FORMAT_BC1_RGB_SRGB_BLOCK:\r\n    case VK_FORMAT_BC1_RGBA_SRGB_BLOCK:"
  "\r\n    case VK_FORMAT_BC2_SRGB_BLOCK:\r\n    case VK_FORMAT_BC2_UNORM_BLOCK:\r\n    case VK_FORMAT_BC3_SRGB_BLOCK:\r\n  "
  "  case VK_FORMAT_BC3_UNORM_BLOCK:\r\n    case VK_FORMAT_BC4_SNORM_BLOCK:\r\n    case VK_FORMAT_BC4_UNORM_BLOCK:\r\n    ca"
  "se VK_FORMAT_BC5_SNORM_BLOCK:\r\n    case VK_FORMAT_BC5_UNORM_BLOCK:\r\n    case VK_FORMAT_BC6H_SFLOAT_BLOCK:\r\n    case"
  " VK_FORMAT_BC6H_UFLOAT_BLOCK:\r\n    case VK_FORMAT_BC7_SRGB_BLOCK:\r\n    case VK_FORMAT_BC7_UNORM_BLOCK: return 4;\r\n\r"
  "\n    default: return 1;\r\n  }\r\n}\r\n\r\nbool IsDepthFormat(VkFormat fmt)\r\n{\r\n  return (fmt == VK_FORMAT_D16_UNORM"
  " || fmt == VK_FORMAT_D16_UNORM_S8_UINT ||\r\n          fmt == VK_FORMAT_D24_UNORM_S8_UINT || fmt == VK_FORMAT_D32_SFLOAT "
  "||\r\n          fmt == VK_FORMAT_D32_SFLOAT_S8_UINT);\r\n}\r\n";
const char fileData_14[] =
  "/******************************************************************************\r\n * The MIT License (MIT)\r\n *\r\n * C"
  "opyright (c) 2018 Google LLC\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n"
  " * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restrict"
  "ion, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or s"
  "ell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the "
  "following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all co"
  "pies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIN"
  "D, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICUL"
  "AR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES"
  " OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTI"
  "ON WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n ********************************************"
  "**********************************/\r\n#include <errno.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#if defin"
  "ed(_WIN32)\r\n#include <direct.h>\r\n#endif\r\n\r\n#include <string>\r\n#include \"helper.h\"\r\n\r\nVkResult CreateVirtu"
  "alSwapchainImages(\r\n    AuxVkTraceResources &aux, const VkSwapchainCreateInfoKHR &swapchainInfo,\r\n    VkImage *images"
  ", uint32_t imageCount) {\r\n  VkImageCreateInfo createInfo = {\r\n      /* sType = */ VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"
  ",\r\n      /* pNext = */ NULL,\r\n      /* flags = */ 0,\r\n      /* imageType = */ VK_IMAGE_TYPE_2D,\r\n      /* format "
  "= */ swapchainInfo.imageFormat,\r\n      {\r\n          /* extent = */\r\n          /* width = */ swapchainInfo.imageExte"
  "nt.width,\r\n          /* height = */ swapchainInfo.imageExtent.height,\r\n          /* depth = */ 1u,\r\n      },\r\n   "
  "   /* mipLevels = */ 1u,\r\n      /* arrayLayers = */ swapchainInfo.imageArrayLayers,\r\n      /* samples = */ VK_SAMPLE_"
  "COUNT_1_BIT,\r\n      /* tiling = */ VK_IMAGE_TILING_OPTIMAL,\r\n      /* usage = */ swapchainInfo.imageUsage | VK_IMAGE_"
  "USAGE_TRANSFER_SRC_BIT,\r\n      /* sharingMode = */ swapchainInfo.imageSharingMode,\r\n      /* queueFamilyIndexCount = "
  "*/ swapchainInfo.queueFamilyIndexCount,\r\n      /* pQueueFamilyIndices = */ swapchainInfo.pQueueFamilyIndices,\r\n      "
  "/* initialLayout = */ VK_IMAGE_LAYOUT_UNDEFINED,\r\n  };\r\n  aux.virtualSwapchainImageCreateInfo = createInfo;\r\n\r\n  "
  "VkMemoryAllocateInfo allocInfo = {\r\n      /* sType = */ VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,\r\n      /* pNext = */ "
  "NULL,\r\n      /* allocationSize = */ 0ull,\r\n      /* memoryTypeIndex = */ 0u,\r\n  };\r\n\r\n  aux.virtualSwapchainIma"
  "ges.resize(imageCount);\r\n  aux.virtualSwapchainImageMemories.resize(imageCount);\r\n\r\n  for (uint32_t i = 0; i < imag"
  "eCount; ++i) {\r\n    VkImage &image = images[i];\r\n    CHECK_VK_SUCCESS(vkCreateImage(aux.device, &createInfo, NULL, &i"
  "mage));\r\n\r\n    VkMemoryRequirements reqs;\r\n    vkGetImageMemoryRequirements(aux.device, image, &reqs);\r\n\r\n    a"
  "llocInfo.memoryTypeIndex =\r\n        MemoryTypeIndex(0, reqs.memoryTypeBits, aux.physDeviceMemoryProperties);\r\n\r\n   "
  " allocInfo.allocationSize = reqs.size;\r\n\r\n    VkDeviceMemory imageMemory;\r\n    CHECK_VK_SUCCESS(\r\n        vkAlloc"
  "ateMemory(aux.device, &allocInfo, NULL, &imageMemory));\r\n\r\n    CHECK_VK_SUCCESS(vkBindImageMemory(aux.device, image, "
  "imageMemory, 0ull));\r\n\r\n    aux.virtualSwapchainImages[i] = image;\r\n    aux.virtualSwapchainImageMemories[i] = imag"
  "eMemory;\r\n  }\r\n  return VK_SUCCESS;\r\n}\r\n\r\nVkResult AcquireVirtualSwapchainImage(AuxVkTraceResources &aux, VkIma"
  "ge image) {\r\n  // transition UNDEFINED -> VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\r\n  VkImageSubresourceRange range = {\r\n   "
  "   /* aspectMask = */ VK_IMAGE_ASPECT_COLOR_BIT,\r\n      /* baseMipLevel = */ 0,\r\n      /* levelCount = */ 1,\r\n     "
  " /* baseArrayLayer = */ 0,\r\n      /* layerCount = */ VK_REMAINING_ARRAY_LAYERS,\r\n  };\r\n  ImageLayoutTransition(aux,"
  " image, range, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);\r\n  return VK_SUCCESS;\r\n}\r\n\r\nVkResult PresentVirtualSwapchainImag"
  "e(AuxVkTraceResources &aux, VkImage image) {\r\n  CHECK_VK_SUCCESS(vkResetFences(aux.device, 1, &aux.fence));\r\n  VkComm"
  "andBufferBeginInfo cmd_buffer_bi = {\r\n      VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, NULL, 0, NULL};\r\n  CHECK_VK_"
  "SUCCESS(vkBeginCommandBuffer(aux.command_buffer, &cmd_buffer_bi));\r\n\r\n  // 1. Acquire real swapchain image\r\n  uint3"
  "2_t imageIndex;\r\n  CHECK_VK_SUCCESS(vkAcquireNextImageKHR(aux.device, aux.swapchain,\r\n                               "
  "          0xFFFFFFFFFF, aux.acquire_semaphore,\r\n                                         NULL, &imageIndex));\r\n  VkIm"
  "age real = aux.realSwapchainImages[imageIndex];\r\n\r\n  // 2. transition image VK_IMAGE_LAYOUT_PRESENT_SRC_KHR ->\r\n  /"
  "/    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL\r\n  // 3. transition real VK_IMAGE_LAYOUT_PRESENT_SRC_KHR ->\r\n  //    VK_IMA"
  "GE_LAYOUT_TRANSFER_DST_OPTIMAL\r\n  VkImageSubresourceRange range = {\r\n      /* aspectMask = */ VK_IMAGE_ASPECT_COLOR_B"
  "IT,\r\n      /* baseMipLevel = */ 0,\r\n      /* levelCount = */ 1,\r\n      /* baseArrayLayer = */ 0,\r\n      /* layerC"
  "ount = */ 1,\r\n  };\r\n  ImageLayoutTransition(aux, image, range, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,\r\n             "
  "           VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);\r\n  ImageLayoutTransition(aux, real, range, VK_IMAGE_LAYOUT_TRANSFER_DST_OP"
  "TIMAL,\r\n                        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);\r\n\r\n  // 4. copy from image to real\r\n  VkImageSu"
  "bresourceLayers copySubresource = {\r\n      /* aspectMask = */ VK_IMAGE_ASPECT_COLOR_BIT,\r\n      /* mipLevel = */ 0u,\r"
  "\n      /* baseArrayLayer = */ 0u,\r\n      /* layerCount = */ 1,\r\n  };\r\n  VkImageCopy copy = {\r\n      /* srcSubres"
  "ource = */ copySubresource,\r\n      /* srcOffset = */\r\n      {\r\n          /* x = */ 0,\r\n          /* y = */ 0,\r\n"
  "          /* z = */ 0,\r\n      },\r\n      /* dstSubresource = */ copySubresource,\r\n      /* dstOffset = */\r\n      {"
  "\r\n          /* x = */ 0,\r\n          /* y = */ 0,\r\n          /* z = */ 0,\r\n      },\r\n      /* extent = */\r\n   "
  "   {\r\n          /* width = */ 0u,\r\n          /* height = */ 0u,\r\n          /* depth = */ 0u,\r\n      },\r\n  };\r\n"
  "  vkCmdCopyImage(aux.command_buffer, image,\r\n                 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, real,\r\n          "
  "       VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy);\r\n\r\n  // 5. transition real VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIM"
  "AL ->\r\n  //     VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\r\n  ImageLayoutTransition(aux, real, range, VK_IMAGE_LAYOUT_PRESENT_SR"
  "C_KHR,\r\n                        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);\r\n\r\n  // 6. present real\r\n\r\n  CHECK_VK_SU"
  "CCESS(vkEndCommandBuffer(aux.command_buffer));\r\n  VkSubmitInfo submitInfo = {\r\n      /* sType = */ VK_STRUCTURE_TYPE_"
  "SUBMIT_INFO,\r\n      /* pNext = */ NULL,\r\n      /* waitSemaphoreCount = */ 1,\r\n      /* pWaitSemaphores = */ &aux.ac"
  "quire_semaphore,\r\n      /* pWaitDstStageMask = */ NULL,\r\n      /* commandBufferCount = */ 1,\r\n      /* pCommandBuff"
  "ers */ &aux.command_buffer,\r\n      /* signalSemaphoreCount = */ 1,\r\n      /* pSignalSemaphores = */ &aux.present_sema"
  "phore,\r\n  };\r\n  CHECK_VK_SUCCESS(vkQueueSubmit(aux.queue, 1, &submitInfo, aux.fence));\r\n\r\n  VkPresentInfoKHR pres"
  "entInfo = {\r\n      /* sType = */ VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\r\n      /* pNext = */ NULL,\r\n      /* waitSemap"
  "horeCount = */ 1,\r\n      /* pWaitSemaphores = */ &aux.present_semaphore,\r\n      /* swapchainCount = */ 1,\r\n      /*"
  " pSwapchains = */ &aux.swapchain,\r\n      /* pImageIndices = */ &imageIndex,\r\n      /* pResults = */ NULL,\r\n  };\r\n"
  "  CHECK_VK_SUCCESS(vkQueuePresentKHR(aux.queue, &presentInfo));\r\n  return VK_SUCCESS;\r\n}\r\n\r\nCheckStream::CheckStr"
  "eam(const char *file, int line, const char *condition) {\r\n  m_stream << \"Check failed [\" << file << \"(\" << line << "
  "\")]: \" << condition\r\n           << \". \";\r\n}\r\n\r\nCheckStream::~CheckStream() {\r\n  m_stream << std::endl;\r\n "
  " std::string message = m_stream.str();\r\n#ifdef _WIN32\r\n  OutputDebugStringA(message.c_str());\r\n#endif\r\n  fwrite(m"
  "essage.data(), message.size(), 1, stderr);\r\n  fflush(stderr);\r\n  std::abort();\r\n}\r\n\r\nstatic PFN_vkDebugMarkerSe"
  "tObjectTagEXT _vkDebugMarkerSetObjectTag = NULL;\r\nstatic PFN_vkDebugMarkerSetObjectNameEXT _vkDebugMarkerSetObjectName "
  "= NULL;\r\nstatic PFN_vkCmdDebugMarkerBeginEXT _vkCmdDebugMarkerBegin = NULL;\r\nstatic PFN_vkCmdDebugMarkerEndEXT _vkCmd"
  "DebugMarkerEnd = NULL;\r\nstatic PFN_vkCmdDebugMarkerInsertEXT _vkCmdDebugMarkerInsert = NULL;\r\nstatic PFN_vkCmdDrawInd"
  "irectCountKHR _vkCmdDrawIndirectCount = NULL;\r\nstatic PFN_vkCmdDrawIndexedIndirectCountKHR _vkCmdDrawIndexedIndirectCou"
  "nt =\r\n    NULL;\r\n\r\nVkResult vkDebugMarkerSetObject(VkDevice device,\r\n                                const VkDebu"
  "gMarkerObjectTagInfoEXT *pTagInfo) {\r\n  return _vkDebugMarkerSetObjectTag\r\n             ? _vkDebugMarkerSetObjectTag("
  "device, pTagInfo)\r\n             : VK_SUCCESS;\r\n}\r\n\r\nVkResult vkDebugMarkerSetObjectName(\r\n    VkDevice device, "
  "const VkDebugMarkerObjectNameInfoEXT *pNameInfo) {\r\n  return _vkDebugMarkerSetObjectName\r\n             ? _vkDebugMark"
  "erSetObjectName(device, pNameInfo)\r\n             : VK_SUCCESS;\r\n}\r\n\r\nvoid vkCmdDebugMarkerBegin(VkCommandBuffer c"
  "ommandBuffer,\r\n                           const VkDebugMarkerMarkerInfoEXT *pMarker) {\r\n  if (_vkCmdDebugMarkerBegin)"
  " _vkCmdDebugMarkerBegin(commandBuffer, pMarker);\r\n}\r\n\r\nvoid vkCmdDebugMarkerEnd(VkCommandBuffer commandBuffer) {\r\n"
  "  if (_vkCmdDebugMarkerEnd) _vkCmdDebugMarkerEnd(commandBuffer);\r\n}\r\n\r\nvoid vkCmdDebugMarkerInsert(VkCommandBuffer "
  "commandBuffer,\r\n                            const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) {\r\n  if (_vkCmdDebugMarker"
  "Insert)\r\n    _vkCmdDebugMarkerInsert(commandBuffer, pMarkerInfo);\r\n}\r\n\r\nvoid vkCmdDrawIndirectCount(VkCommandBuff"
  "er commandBuffer, VkBuffer buffer,\r\n                            VkDeviceSize offset, VkBuffer countBuffer,\r\n         "
  "                   VkDeviceSize countBufferOffset,\r\n                            uint32_t maxDrawCount, uint32_t stride)"
  " {\r\n  if (_vkCmdDrawIndirectCount)\r\n    _vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer,\r\n      "
  "                      countBufferOffset, maxDrawCount, stride);\r\n}\r\n\r\nvoid vkCmdDrawIndexedIndirectCount(VkCommandB"
  "uffer commandBuffer,\r\n                                   VkBuffer buffer, VkDeviceSize offset,\r\n                     "
  "              VkBuffer countBuffer,\r\n                                   VkDeviceSize countBufferOffset,\r\n            "
  "                       uint32_t maxDrawCount, uint32_t stride) {\r\n  if (_vkCmdDrawIndexedIndirectCount)\r\n    _vkCmdDr"
  "awIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer,\r\n                                   countBufferOffse"
  "t, maxDrawCount, stride);\r\n}\r\n\r\nVkBool32 VKAPI_PTR DebugCallback(VkDebugReportFlagsEXT flags,\r\n                  "
  "               VkDebugReportObjectTypeEXT objectType,\r\n                                 uint64_t object, size_t locatio"
  "n,\r\n                                 int32_t messageCode, const char *pLayerPrefix,\r\n                                "
  " const char *pMessage, void *pUserData) {\r\n  switch (flags) {\r\n    case VK_DEBUG_REPORT_ERROR_BIT_EXT:\r\n    case VK"
  "_DEBUG_REPORT_DEBUG_BIT_EXT:\r\n      fprintf(stderr, \"%s\\n\", pMessage);\r\n#if defined(_WIN32)\r\n      OutputDebugSt"
  "ringA(pMessage);\r\n      OutputDebugStringA(\"\\n\");\r\n#endif\r\n  }\r\n\r\n  return VK_FALSE;\r\n}\r\n\r\nvoid Regist"
  "erDebugCallback(AuxVkTraceResources *aux, VkInstance instance,\r\n                           VkDebugReportFlagsEXT flags,"
  "\r\n                           VkDebugReportCallbackEXT *pCallback,\r\n                           PFN_vkDebugReportCallba"
  "ckEXT pfnCallBack) {\r\n  PFN_vkCreateDebugReportCallbackEXT CreateDebugReportCallback = VK_NULL_HANDLE;\r\n  CreateDebug"
  "ReportCallback =\r\n      (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(\r\n          instance, \"vkCreateDeb"
  "ugReportCallbackEXT\");\r\n\r\n  VkDebugReportCallbackCreateInfoEXT ci = {\r\n      VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBA"
  "CK_CREATE_INFO_EXT, 0, flags,\r\n      (pfnCallBack == VK_NULL_HANDLE) ? DebugCallback : pfnCallBack, NULL};\r\n  if (Cre"
  "ateDebugReportCallback != NULL) {\r\n    CHECK_VK_SUCCESS(CreateDebugReportCallback(instance, &ci, NULL, pCallback));\r\n"
  "  }\r\n}\r\nstatic VKAPI_ATTR VkBool32 VKAPI_CALL\r\nDebugUtilsCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSev"
  "erity,\r\n                   VkDebugUtilsMessageTypeFlagsEXT messageType,\r\n                   const VkDebugUtilsMesseng"
  "erCallbackDataEXT *pCallbackData,\r\n                   void *pUserData) {\r\n  if (messageSeverity & (VK_DEBUG_UTILS_MES"
  "SAGE_SEVERITY_ERROR_BIT_EXT |\r\n                         VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)) {\r\n    std:"
  ":ostringstream msg;\r\n    msg << \"Validation \";\r\n    if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT"
  "_EXT)\r\n      msg << \"ERROR: \";\r\n    else if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)\r\n"
  "      msg << \"WARNING: \";\r\n    msg << \"[\" << pCallbackData->pMessageIdName\r\n        << \"]: \" << pCallbackData->"
  "pMessage << std::endl;\r\n    fprintf(stderr, \"%s\", msg.str().c_str());\r\n#if defined(_WIN32)\r\n    OutputDebugString"
  "A(msg.str().c_str());\r\n#endif\r\n  }\r\n  return VK_FALSE;\r\n}\r\n\r\nVkDebugUtilsMessengerCreateInfoEXT DebugUtilsMes"
  "sengerCreateInfo(\r\n    VkDebugUtilsMessageSeverityFlagsEXT severity,\r\n    VkDebugUtilsMessageTypeFlagsEXT type,\r\n  "
  "  PFN_vkDebugUtilsMessengerCallbackEXT pfnCallback) {\r\n  return {\r\n      /* sType = */ VK_STRUCTURE_TYPE_DEBUG_UTILS_"
  "MESSENGER_CREATE_INFO_EXT,\r\n      /* pNext = */ NULL,\r\n      /* flags = */ 0,\r\n      /* messageSeverity = */ severi"
  "ty,\r\n      /* messageType = */ type,\r\n      /* pfnUserCallback = */\r\n      (pfnCallback == VK_NULL_HANDLE) ? DebugU"
  "tilsCallback : pfnCallback,\r\n      /* pUserData = */ NULL,\r\n  };\r\n}\r\n\r\nvoid RegisterDebugUtilsCallback(\r\n    "
  "AuxVkTraceResources *aux, VkInstance instance,\r\n    VkDebugUtilsMessageSeverityFlagsEXT severity,\r\n    VkDebugUtilsMe"
  "ssageTypeFlagsEXT type, VkDebugUtilsMessengerEXT *pMessenger,\r\n    PFN_vkDebugUtilsMessengerCallbackEXT pfnCallback) {\r"
  "\n  PFN_vkCreateDebugUtilsMessengerEXT CreateDebugUtilsMessenger =\r\n      (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInst"
  "anceProcAddr(\r\n          instance, \"vkCreateDebugUtilsMessengerEXT\");\r\n\r\n  if (CreateDebugUtilsMessenger != NULL)"
  " {\r\n    VkDebugUtilsMessengerCreateInfoEXT ci =\r\n        DebugUtilsMessengerCreateInfo(severity, type, pfnCallback);\r"
  "\n    CHECK_VK_SUCCESS(\r\n        CreateDebugUtilsMessenger(instance, &ci, NULL, pMessenger));\r\n  }\r\n}\r\n\r\n#ifdef"
  " _WIN32\r\n#include <vulkan/vulkan_win32.h>\r\nVkResult CreateSurface(AuxVkTraceResources &aux) {\r\n  VkWin32SurfaceCrea"
  "teInfoKHR surfaceCreateInfo = {\r\n      /* sType = */ VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,\r\n      /* pNext"
  " = */ NULL,\r\n      /* flags = */ 0,\r\n      /* hinstance = */ aux.hInstance,\r\n      /* hwnd = */ aux.hWnd,\r\n  };\r"
  "\n  return vkCreateWin32SurfaceKHR(aux.instance, &surfaceCreateInfo, NULL,\r\n                                 &aux.surfa"
  "ce);\r\n}\r\n#endif\r\n\r\nVkPresentModeKHR GetCompatiblePresentMode(\r\n    VkPresentModeKHR captured, std::vector<VkPre"
  "sentModeKHR> present) {\r\n  for (uint32_t i = 0; i < present.size(); i++)\r\n    if (present[i] == captured) return capt"
  "ured;\r\n\r\n  CHECK(present.size() > 0);\r\n  return present[0];\r\n}\r\n\r\nvoid ImageLayoutTransition(VkCommandBuffer "
  "cmdBuffer, VkImage dstImage,\r\n                           VkImageSubresourceRange subresourceRange,\r\n                 "
  "          VkImageLayout newLayout, uint32_t dstQueueFamily,\r\n                           VkImageLayout oldLayout, uint32"
  "_t srcQueueFamily) {\r\n  uint32_t all_access =\r\n      VK_ACCESS_INDIRECT_COMMAND_READ_BIT | VK_ACCESS_INDEX_READ_BIT |"
  "\r\n      VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT | VK_ACCESS_UNIFORM_READ_BIT |\r\n      VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"
  " | VK_ACCESS_SHADER_READ_BIT |\r\n      VK_ACCESS_SHADER_WRITE_BIT | VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |\r\n      VK_AC"
  "CESS_COLOR_ATTACHMENT_WRITE_BIT |\r\n      VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |\r\n      VK_ACCESS_DEPTH_STENCIL"
  "_ATTACHMENT_WRITE_BIT |\r\n      VK_ACCESS_TRANSFER_READ_BIT | VK_ACCESS_TRANSFER_WRITE_BIT |\r\n      VK_ACCESS_HOST_REA"
  "D_BIT | VK_ACCESS_HOST_WRITE_BIT;\r\n\r\n  VkImageMemoryBarrier imgBarrier = {VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,\r\n"
  "                                     NULL,\r\n                                     all_access,\r\n                       "
  "              VK_ACCESS_TRANSFER_WRITE_BIT,\r\n                                     oldLayout,\r\n                       "
  "              newLayout,\r\n                                     srcQueueFamily,\r\n                                     "
  "dstQueueFamily,\r\n                                     dstImage,\r\n                                     subresourceRang"
  "e};\r\n\r\n  vkCmdPipelineBarrier(cmdBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,\r\n                       VK_PIPELINE_ST"
  "AGE_ALL_COMMANDS_BIT, 0, 0, NULL, 0, NULL,\r\n                       1, &imgBarrier);\r\n}\r\n\r\nvoid ImageLayoutTransit"
  "ion(const AuxVkTraceResources &aux, VkImage dstImage,\r\n                           VkImageSubresourceRange subresourceRa"
  "nge,\r\n                           VkImageLayout newLayout, VkImageLayout oldLayout) {\r\n  ImageLayoutTransition(aux.com"
  "mand_buffer, dstImage, subresourceRange,\r\n                        newLayout, VK_QUEUE_FAMILY_IGNORED, oldLayout,\r\n   "
  "                     VK_QUEUE_FAMILY_IGNORED);\r\n}\r\n\r\nvoid ImageLayoutTransition(const AuxVkTraceResources &aux, VkI"
  "mage dstImage,\r\n                           VkImageCreateInfo dstCI, VkImageLayout newLayout,\r\n                       "
  "    VkImageLayout oldLayout) {\r\n  VkImageSubresourceRange subresourceRange = {\r\n      FullAspectFromFormat(dstCI.form"
  "at), 0, VK_REMAINING_MIP_LEVELS, 0,\r\n      VK_REMAINING_ARRAY_LAYERS};\r\n\r\n  ImageLayoutTransition(aux, dstImage, su"
  "bresourceRange, newLayout, oldLayout);\r\n}\r\n\r\nvoid ImageLayoutTransition(const AuxVkTraceResources &aux, VkImage dst"
  "Img,\r\n                           uint32_t arrayLayer, uint32_t mipLevel,\r\n                           VkImageAspectFla"
  "gBits aspect,\r\n                           VkImageLayout newLayout, VkImageLayout oldLayout) {\r\n  VkImageSubresourceRa"
  "nge subresourceRange = {VkImageAspectFlags(aspect),\r\n                                              mipLevel, 1, arrayLa"
  "yer, 1};\r\n\r\n  ImageLayoutTransition(aux, dstImg, subresourceRange, newLayout, oldLayout);\r\n}\r\n\r\nvoid CopyResetI"
  "mage(const AuxVkTraceResources &aux, VkImage dst, VkBuffer src,\r\n                    VkImageCreateInfo dst_ci) {\r\n  I"
  "mageLayoutTransition(aux, dst, dst_ci, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);\r\n\r\n  if (dst_ci.samples == VK_SAMPLE_CO"
  "UNT_1_BIT) {\r\n    VkImageAspectFlags aspect = FullAspectFromFormat(dst_ci.format);\r\n    VkImageAspectFlags color_dept"
  "h_stencil = VK_IMAGE_ASPECT_COLOR_BIT |\r\n                                             VK_IMAGE_ASPECT_DEPTH_BIT |\r\n  "
  "                                           VK_IMAGE_ASPECT_STENCIL_BIT;\r\n\r\n    // only color, depth or stencil aspect"
  "s are allowed\r\n    CHECK(((aspect & color_depth_stencil) != 0) &&\r\n          ((aspect & (~color_depth_stencil)) == 0)"
  ");\r\n\r\n    std::vector<VkImageAspectFlagBits> aspects;\r\n    if (aspect & VK_IMAGE_ASPECT_COLOR_BIT)\r\n      aspects"
  ".push_back(VK_IMAGE_ASPECT_COLOR_BIT);\r\n    if (aspect & VK_IMAGE_ASPECT_DEPTH_BIT)\r\n      aspects.push_back(VK_IMAGE"
  "_ASPECT_DEPTH_BIT);\r\n    if (aspect & VK_IMAGE_ASPECT_STENCIL_BIT)\r\n      aspects.push_back(VK_IMAGE_ASPECT_STENCIL_B"
  "IT);\r\n\r\n    std::vector<VkBufferImageCopy> regions;\r\n    uint32_t offset = 0;\r\n    for (uint32_t a = 0; a < dst_c"
  "i.arrayLayers; a++) {\r\n      VkExtent3D dim = dst_ci.extent;\r\n      for (uint32_t m = 0; m < dst_ci.mipLevels; m++) {"
  "\r\n        for (uint32_t j = 0; j < aspects.size(); j++) {\r\n          // TODO(b/137277795): fix FixCompressedSizes, it"
  " always aligns to 4.\r\n          FixCompressedSizes(dst_ci.format, dim, offset);\r\n          VkBufferImageCopy region ="
  " {\r\n              offset,     dim.width,\r\n              dim.height, {VkImageAspectFlags(aspects[j]), m, a, 1},\r\n   "
  "           {0, 0, 0},  dim};\r\n          regions.push_back(region);\r\n          offset += (uint32_t)(dim.depth * dim.wi"
  "dth * dim.height *\r\n                               SizeOfFormat(dst_ci.format, aspects[j]));\r\n        }\r\n        di"
  "m.height = std::max<int>(dim.height / 2, 1);\r\n        dim.width = std::max<int>(dim.width / 2, 1);\r\n        dim.depth"
  " = std::max<int>(dim.depth / 2, 1);\r\n      }  // array\r\n    }    // mip\r\n    const uint32_t kMaxUpdate = 100;\r\n  "
  "  for (uint32_t i = 0; i * kMaxUpdate < regions.size(); i++) {\r\n      uint32_t count = std::min<uint32_t>(\r\n         "
  " kMaxUpdate, (uint32_t)regions.size() - i * kMaxUpdate);\r\n      uint32_t offset = i * kMaxUpdate;\r\n      vkCmdCopyBuf"
  "ferToImage(aux.command_buffer, src, dst,\r\n                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, count,\r\n"
  "                             regions.data() + offset);\r\n    }\r\n  } else {\r\n    std::string msg =\r\n        std::st"
  "ring(__FUNCTION__) +\r\n        std::string(\": resets MSAA resource with \") +\r\n        std::to_string(dst_ci.samples)"
  " +\r\n        std::string(\" samples. Currently this is not implemented.\\n\");\r\n    printf(\"%s\", msg.c_str());\r\n#i"
  "fdef _WIN32\r\n    OutputDebugStringA(msg.c_str());\r\n#endif\r\n  }\r\n}\r\nvoid CopyResetBuffer(const AuxVkTraceResourc"
  "es &aux, VkBuffer dst, VkBuffer src,\r\n                     VkDeviceSize size) {\r\n  if (size == 0) return;\r\n  VkBuff"
  "erCopy region = {0, 0, size};\r\n  vkCmdCopyBuffer(aux.command_buffer, src, dst, 1, &region);\r\n}\r\n\r\nvoid CopyImageT"
  "oBuffer(const AuxVkTraceResources &aux, VkImage src,\r\n                       VkBuffer dst, VkImageCreateInfo src_ci) {\r"
  "\n  CHECK(src_ci.samples == VK_SAMPLE_COUNT_1_BIT);\r\n  if (src_ci.samples == VK_SAMPLE_COUNT_1_BIT) {\r\n    VkImageAsp"
  "ectFlags aspect = FullAspectFromFormat(src_ci.format);\r\n    VkImageAspectFlags color_depth_stencil = VK_IMAGE_ASPECT_CO"
  "LOR_BIT |\r\n                                             VK_IMAGE_ASPECT_DEPTH_BIT |\r\n                                "
  "             VK_IMAGE_ASPECT_STENCIL_BIT;\r\n    // only color, depth or stencil aspects are allowed\r\n    CHECK(((aspec"
  "t & color_depth_stencil) != 0) &&\r\n          ((aspect & (~color_depth_stencil)) == 0));\r\n\r\n    std::vector<VkImageA"
  "spectFlagBits> aspects;\r\n    if (aspect & VK_IMAGE_ASPECT_COLOR_BIT)\r\n      aspects.push_back(VK_IMAGE_ASPECT_COLOR_B"
  "IT);\r\n    if (aspect & VK_IMAGE_ASPECT_DEPTH_BIT)\r\n      aspects.push_back(VK_IMAGE_ASPECT_DEPTH_BIT);\r\n    if (asp"
  "ect & VK_IMAGE_ASPECT_STENCIL_BIT)\r\n      aspects.push_back(VK_IMAGE_ASPECT_STENCIL_BIT);\r\n\r\n    std::vector<VkBuff"
  "erImageCopy> regions;\r\n    uint32_t offset = 0;\r\n\r\n    for (uint32_t a = 0; a < src_ci.arrayLayers; a++) {\r\n     "
  " VkExtent3D dim = src_ci.extent;\r\n      for (uint32_t m = 0; m < src_ci.mipLevels; m++) {\r\n        for (uint32_t j = "
  "0; j < aspects.size(); j++) {\r\n          // TODO(b/137277795): fix FixCompressedSizes, it always aligns to 4.\r\n      "
  "    FixCompressedSizes(src_ci.format, dim, offset);\r\n          VkBufferImageCopy region = {\r\n              offset,   "
  "  dim.width,\r\n              dim.height, {VkImageAspectFlags(aspects[j]), m, a, 1},\r\n              {0, 0, 0},  dim};\r"
  "\n          regions.push_back(region);\r\n          offset += (uint32_t)(dim.depth * dim.width * dim.height *\r\n        "
  "                       SizeOfFormat(src_ci.format, aspects[j]));\r\n        }\r\n        dim.height = std::max<int>(dim.h"
  "eight / 2, 1);\r\n        dim.width = std::max<int>(dim.width / 2, 1);\r\n        dim.depth = std::max<int>(dim.depth / 2"
  ", 1);\r\n      }\r\n    }\r\n    const uint32_t kMaxUpdate = 100;\r\n    for (uint32_t i = 0; i * kMaxUpdate < regions.si"
  "ze(); i++) {\r\n      uint32_t count = std::min<uint32_t>(\r\n          kMaxUpdate, (uint32_t)regions.size() - i * kMaxUp"
  "date);\r\n      uint32_t offset = i * kMaxUpdate;\r\n      vkCmdCopyImageToBuffer(aux.command_buffer, src,\r\n           "
  "                  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, dst, count,\r\n                             regions.data() + offs"
  "et);\r\n    }\r\n  }\r\n}\r\n\r\nvoid DiffDeviceMemory(const AuxVkTraceResources &aux, VkDeviceMemory expected,\r\n      "
  "                VkDeviceSize expected_offset, VkDeviceMemory actual,\r\n                      VkDeviceSize actual_offset,"
  " VkDeviceSize size,\r\n                      const char *name) {\r\n  uint8_t *expected_data = NULL;\r\n  CHECK_VK_SUCCES"
  "S(vkMapMemory(aux.device, actual, actual_offset, size, 0,\r\n                               (void **)&expected_data));\r\n"
  "\r\n  uint8_t *actual_data = NULL;\r\n  CHECK_VK_SUCCESS(vkMapMemory(aux.device, expected, expected_offset, size, 0,\r\n "
  "                              (void **)&actual_data));\r\n\r\n  if (memcmp(expected_data, actual_data, (size_t)size) != 0"
  ") {\r\n    std::string msg = std::string(__FUNCTION__) + std::string(\": Resource \") +\r\n                      std::str"
  "ing(name) +\r\n                      std::string(\" has changed by the end of the frame.\\n\");\r\n    printf(\"%s\", msg"
  ".c_str());\r\n  }\r\n\r\n  vkUnmapMemory(aux.device, expected);\r\n  vkUnmapMemory(aux.device, actual);\r\n}\r\n\r\nvoid "
  "InitializeDiffBuffer(VkDevice device, VkBuffer *buffer,\r\n                          VkDeviceMemory *memory, size_t size,"
  "\r\n                          VkPhysicalDeviceMemoryProperties props) {\r\n  CHECK(buffer != NULL && memory != NULL);\r\n"
  "  if (size == 0) return;\r\n\r\n  VkBufferCreateInfo buffer_ci = {\r\n      VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\r\n    "
  "  NULL,\r\n      0,\r\n      size,\r\n      VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,\r\n     "
  " VK_SHARING_MODE_EXCLUSIVE,\r\n      0,\r\n      NULL};\r\n\r\n  CHECK_VK_SUCCESS(vkCreateBuffer(device, &buffer_ci, NULL"
  ", buffer));\r\n\r\n  VkMemoryRequirements buffer_requirements;\r\n  vkGetBufferMemoryRequirements(device, *buffer, &buffe"
  "r_requirements);\r\n\r\n  VkFlags gpu_and_cpu_visible = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;\r\n  uint32_t memory_type = "
  "MemoryTypeIndex(\r\n      gpu_and_cpu_visible, buffer_requirements.memoryTypeBits, props);\r\n\r\n  VkMemoryAllocateInfo "
  "memory_ai = {VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,\r\n                                    NULL, buffer_requirements.siz"
  "e,\r\n                                    memory_type};\r\n\r\n  CHECK_VK_SUCCESS(vkAllocateMemory(device, &memory_ai, NU"
  "LL, memory));\r\n  CHECK_VK_SUCCESS(vkBindBufferMemory(device, *buffer, *memory, 0));\r\n}\r\n\r\nvoid InitializeDestinat"
  "ionBuffer(VkDevice device, VkBuffer *dst_buffer,\r\n                                 VkDeviceMemory dst_memory, uint64_t "
  "size) {\r\n  CHECK(dst_buffer != NULL);\r\n  if (size == 0) return;\r\n\r\n  VkBufferCreateInfo buffer_dst_ci = {\r\n    "
  "  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\r\n      NULL,\r\n      0,\r\n      size,\r\n      VK_BUFFER_USAGE_TRANSFER_SRC_B"
  "IT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,\r\n      VK_SHARING_MODE_EXCLUSIVE,\r\n      0,\r\n      NULL};\r\n\r\n  CHECK_VK_"
  "SUCCESS(vkCreateBuffer(device, &buffer_dst_ci, NULL, dst_buffer));\r\n  CHECK_VK_SUCCESS(vkBindBufferMemory(device, *dst_"
  "buffer, dst_memory, 0));\r\n}\r\n\r\nvoid InitializeSourceBuffer(VkDevice device, VkBuffer *src_buffer,\r\n              "
  "              VkDeviceMemory *src_memory, size_t size,\r\n                            uint8_t *initial_data,\r\n         "
  "                   VkPhysicalDeviceMemoryProperties props,\r\n                            MemoryRemapVec &remap) {\r\n  C"
  "HECK(src_buffer != NULL && src_memory != NULL);\r\n  if (size == 0) return;\r\n\r\n  VkBufferCreateInfo buffer_src_ci = {"
  "\r\n      VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\r\n      NULL,\r\n      0,\r\n      size,\r\n      VK_BUFFER_USAGE_TRANSF"
  "ER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,\r\n      VK_SHARING_MODE_EXCLUSIVE,\r\n      0,\r\n      NULL};\r\n\r\n  C"
  "HECK_VK_SUCCESS(vkCreateBuffer(device, &buffer_src_ci, NULL, src_buffer));\r\n\r\n  VkMemoryRequirements buffer_requireme"
  "nts;\r\n  vkGetBufferMemoryRequirements(device, *src_buffer, &buffer_requirements);\r\n\r\n  VkFlags gpu_and_cpu_visible "
  "= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;\r\n  uint32_t memory_type = MemoryTypeIndex(\r\n      gpu_and_cpu_visible, buffer_"
  "requirements.memoryTypeBits, props);\r\n\r\n  VkMemoryAllocateInfo memory_ai = {VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,\r"
  "\n                                    NULL, buffer_requirements.size,\r\n                                    memory_type}"
  ";\r\n\r\n  CHECK_VK_SUCCESS(vkAllocateMemory(device, &memory_ai, NULL, src_memory));\r\n  CHECK_VK_SUCCESS(vkBindBufferMe"
  "mory(device, *src_buffer, *src_memory, 0));\r\n\r\n  uint8_t *data = NULL;\r\n  CHECK_VK_SUCCESS(\r\n      vkMapMemory(de"
  "vice, *src_memory, 0, size, 0, (void **)&data));\r\n\r\n  // For each resource bound in the memory allocation, copy the c"
  "orrect\r\n  // memory segment into 'src' buffer.\r\n  if (remap.size() > 0) {\r\n    for (uint32_t i = 0; i < remap.size("
  "); i++) {\r\n      MemoryRemap mr = remap[i];\r\n      if (mr.replay.offset + mr.replay.size <= size) {\r\n        memcpy"
  "(data + mr.replay.offset, initial_data + mr.capture.offset,\r\n               std::min<uint64_t>(mr.capture.size, mr.repl"
  "ay.size));\r\n      }\r\n    }\r\n  } else {\r\n    memcpy(data, initial_data, size);\r\n  }\r\n\r\n  VkMappedMemoryRange"
  " memory_range = {VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,\r\n                                      NULL, *src_memory, 0, si"
  "ze};\r\n\r\n  CHECK_VK_SUCCESS(vkFlushMappedMemoryRanges(device, 1, &memory_range));\r\n\r\n  vkUnmapMemory(device, *src_"
  "memory);\r\n}\r\n\r\nvoid InitializeAuxResources(AuxVkTraceResources *aux, VkInstance instance,\r\n                      "
  "      VkPhysicalDevice physDevice, VkDevice device) {\r\n  aux->instance = instance;\r\n  aux->physDevice = physDevice;\r"
  "\n  aux->device = device;\r\n  vkGetPhysicalDeviceProperties(aux->physDevice, &aux->physDeviceProperties);\r\n\r\n  vkGet"
  "DeviceQueue(device, 0, 0, &aux->queue);\r\n\r\n  VkCommandPoolCreateInfo cmd_pool_ci = {\r\n      VK_STRUCTURE_TYPE_COMMA"
  "ND_POOL_CREATE_INFO, NULL,\r\n      VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT, 0};\r\n\r\n  CHECK_VK_SUCCESS(\r\n  "
  "    vkCreateCommandPool(device, &cmd_pool_ci, NULL, &aux->command_pool));\r\n\r\n  VkCommandBufferAllocateInfo cmd_buffer"
  "_ai = {\r\n      VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, NULL, aux->command_pool,\r\n      VK_COMMAND_BUFFER_LEVE"
  "L_PRIMARY, 1};\r\n\r\n  CHECK_VK_SUCCESS(\r\n      vkAllocateCommandBuffers(device, &cmd_buffer_ai, &aux->command_buffer)"
  ");\r\n\r\n  VkFenceCreateInfo fence_ci = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, NULL, 0};\r\n\r\n  CHECK_VK_SUCCESS(vkCrea"
  "teFence(device, &fence_ci, NULL, &aux->fence));\r\n\r\n  VkSemaphoreCreateInfo semaphore_ci = {VK_STRUCTURE_TYPE_SEMAPHOR"
  "E_CREATE_INFO,\r\n                                        NULL, 0};\r\n  CHECK_VK_SUCCESS(\r\n      vkCreateSemaphore(dev"
  "ice, &semaphore_ci, NULL, &aux->acquire_semaphore));\r\n  CHECK_VK_SUCCESS(\r\n      vkCreateSemaphore(device, &semaphore"
  "_ci, NULL, &aux->present_semaphore));\r\n\r\n  if (IsExtSupported(aux->physDevice, \"VK_EXT_debug_marker\")) {\r\n    _vk"
  "DebugMarkerSetObjectTag =\r\n        (PFN_vkDebugMarkerSetObjectTagEXT)vkGetInstanceProcAddr(\r\n            instance, \""
  "vkDebugMarkerSetObjectTagEXT\");\r\n    _vkDebugMarkerSetObjectName =\r\n        (PFN_vkDebugMarkerSetObjectNameEXT)vkGet"
  "InstanceProcAddr(\r\n            instance, \"vkDebugMarkerSetObjectNameEXT\");\r\n    _vkCmdDebugMarkerBegin =\r\n       "
  " (PFN_vkCmdDebugMarkerBeginEXT)vkGetInstanceProcAddr(\r\n            instance, \"vkCmdDebugMarkerBeginEXT\");\r\n    _vkC"
  "mdDebugMarkerEnd = (PFN_vkCmdDebugMarkerEndEXT)vkGetInstanceProcAddr(\r\n        instance, \"vkCmdDebugMarkerEndEXT\");\r"
  "\n    _vkCmdDebugMarkerInsert =\r\n        (PFN_vkCmdDebugMarkerInsertEXT)vkGetInstanceProcAddr(\r\n            instance,"
  " \"vkCmdDebugMarkerInsertEXT\");\r\n  }\r\n\r\n  if (IsExtSupported(aux->physDevice, \"VK_KHR_draw_indirect_count\")) {\r"
  "\n    _vkCmdDrawIndirectCount =\r\n        (PFN_vkCmdDrawIndirectCountKHR)vkGetDeviceProcAddr(\r\n            device, \"v"
  "kCmdDrawIndirectCountKHR\");\r\n    _vkCmdDrawIndexedIndirectCount =\r\n        (PFN_vkCmdDrawIndexedIndirectCountKHR)vkG"
  "etDeviceProcAddr(\r\n            device, \"vkCmdDrawIndexedIndirectCountKHR\");\r\n  }\r\n\r\n  uint32_t queueFamilyPrope"
  "rtyCount;\r\n  vkGetPhysicalDeviceQueueFamilyProperties(aux->physDevice,\r\n                                           &q"
  "ueueFamilyPropertyCount, NULL);\r\n  CHECK(queueFamilyPropertyCount != 0);\r\n  aux->queueFamilyProperties.resize(queueFa"
  "milyPropertyCount);\r\n  vkGetPhysicalDeviceQueueFamilyProperties(aux->physDevice,\r\n                                   "
  "        &queueFamilyPropertyCount,\r\n                                           aux->queueFamilyProperties.data());\r\n}"
  "\r\n\r\nint32_t MemoryTypeIndex(VkMemoryPropertyFlags mask, uint32_t bits,\r\n                        const VkPhysicalDev"
  "iceMemoryProperties &memory_props) {\r\n  for (uint32_t i = 0; i < memory_props.memoryTypeCount; ++i) {\r\n    if ((bits "
  "& 1) == 1) {\r\n      // Type is available, does it match user properties?\r\n      if ((memory_props.memoryTypes[i].prop"
  "ertyFlags & mask) == mask) {\r\n        return i;\r\n      }\r\n    }\r\n    bits = bits >> 1;\r\n  }\r\n  return -1;\r\n"
  "}\r\n\r\nuint32_t CompatibleMemoryTypeIndex(\r\n    uint32_t type, const VkPhysicalDeviceMemoryProperties &captured,\r\n "
  "   const VkPhysicalDeviceMemoryProperties &present, uint32_t bits) {\r\n  // When the application was captured this is th"
  "e property flag that was\r\n  // picked as compatible. Try to find the closest match.\r\n  // This if fairly conservative"
  " and here is an example where this might fail:\r\n  // Let System A, where the trace is captured, has all the memory mark"
  "ed as\r\n  // DEVICE_LOCAL_BIT | HOST_VISIBLE_BIT (for example UMA devices).\r\n  // The application requests a memory al"
  "location with just a\r\n  // HOST_VISIBLE_BIT but gets a memory type index that points to\r\n  // HOST_VISIBLE_BIT | DEVI"
  "CE_LOCAL_BIT. On System B, memory is split into:\r\n  // 1. HOST_VISIBLE 2. DEVICE_LOCAL and 3. HOST_VISIBLE | DEVICE_LOC"
  "AL.\r\n  // Since the captured memory type was HOST_VISIBLE | DEVICE_LOCAL on replay\r\n  // the 3rd memory segment will "
  "get selected.\r\n  VkMemoryType mem_type = captured.memoryTypes[type];\r\n  VkMemoryPropertyFlags propertyFlag = mem_type"
  ".propertyFlags;\r\n\r\n  // All memory types are approved with 0xFFFFFFFF bits\r\n  return MemoryTypeIndex(propertyFlag, "
  "bits, present);\r\n}\r\n\r\nVkResult CheckMemoryAllocationCompatibility(\r\n    uint32_t type, const VkPhysicalDeviceMemo"
  "ryProperties &captured,\r\n    const VkPhysicalDeviceMemoryProperties &present,\r\n    const VkMemoryRequirements &requir"
  "ements) {\r\n  VkMemoryType mem_type = captured.memoryTypes[type];\r\n  VkMemoryPropertyFlags propertyFlag = mem_type.pro"
  "pertyFlags;\r\n\r\n  uint32_t compat_type = CompatibleMemoryTypeIndex(type, captured, present,\r\n                       "
  "                            requirements.memoryTypeBits);\r\n\r\n  uint32_t current =\r\n      MemoryTypeIndex(propertyFl"
  "ag, requirements.memoryTypeBits, present);\r\n\r\n  return (compat_type == current ? VK_SUCCESS : VK_ERROR_VALIDATION_FAI"
  "LED_EXT);\r\n}\r\n\r\nvoid ReadBuffer(const char *name, std::vector<uint8_t> &buf) {\r\n  FILE *f = OpenFile(name, \"rb\""
  ");\r\n  CHECK(f != NULL) << \"Unable to open file: \" << name;\r\n\r\n  fseek(f, 0, SEEK_END);\r\n#if defined(_WIN32)\r\n"
  "  int64_t length = _ftelli64(f);\r\n#else\r\n  int64_t length = ftell(f);\r\n#endif\r\n  CHECK(length >= 0) << \"Failed t"
  "o obtain file size for '\" << name << \"'\";\r\n  size_t buf_size = static_cast<size_t>(length);\r\n  buf.resize(buf_size"
  ");\r\n  rewind(f);\r\n\r\n  size_t result = fread(buf.data(), 1, buf_size, f);\r\n  fclose(f);\r\n  CHECK(result <= buf_s"
  "ize) << \"Read more bytes (\" << result << \") from file '\"\r\n                            << name << \"' than expected "
  "(\" << buf_size << \")\";\r\n}\r\n\r\n#define ReportMismatchedFeature(x, y)                                   \\\r\n  if "
  "(x > y) {                                                          \\\r\n    fprintf(stderr, \"%s (%d) doesn't match %s ("
  "%d)\\n\", STRINGIFY(x), x, \\\r\n            STRINGIFY(y), y);                                           \\\r\n    x = y;"
  "                                                              \\\r\n  }\r\n\r\nvoid MakePhysicalDeviceFeaturesMatch(\r\n "
  "   const VkPhysicalDeviceFeatures &available,\r\n    VkPhysicalDeviceFeatures *captured_request) {\r\n  ReportMismatchedF"
  "eature(captured_request->robustBufferAccess,\r\n                          available.robustBufferAccess);\r\n  ReportMisma"
  "tchedFeature(captured_request->fullDrawIndexUint32,\r\n                          available.fullDrawIndexUint32);\r\n  Rep"
  "ortMismatchedFeature(captured_request->imageCubeArray,\r\n                          available.imageCubeArray);\r\n  Repor"
  "tMismatchedFeature(captured_request->independentBlend,\r\n                          available.independentBlend);\r\n  Rep"
  "ortMismatchedFeature(captured_request->geometryShader,\r\n                          available.geometryShader);\r\n  Repor"
  "tMismatchedFeature(captured_request->tessellationShader,\r\n                          available.tessellationShader);\r\n "
  " ReportMismatchedFeature(captured_request->sampleRateShading,\r\n                          available.sampleRateShading);\r"
  "\n  ReportMismatchedFeature(captured_request->dualSrcBlend,\r\n                          available.dualSrcBlend);\r\n  Re"
  "portMismatchedFeature(captured_request->logicOp, available.logicOp);\r\n  ReportMismatchedFeature(captured_request->multi"
  "DrawIndirect,\r\n                          available.multiDrawIndirect);\r\n  ReportMismatchedFeature(captured_request->d"
  "rawIndirectFirstInstance,\r\n                          available.drawIndirectFirstInstance);\r\n  ReportMismatchedFeature"
  "(captured_request->depthClamp, available.depthClamp);\r\n  ReportMismatchedFeature(captured_request->depthBiasClamp,\r\n "
  "                         available.depthBiasClamp);\r\n  ReportMismatchedFeature(captured_request->fillModeNonSolid,\r\n "
  "                         available.fillModeNonSolid);\r\n  ReportMismatchedFeature(captured_request->depthBounds, availab"
  "le.depthBounds);\r\n  ReportMismatchedFeature(captured_request->wideLines, available.wideLines);\r\n  ReportMismatchedFea"
  "ture(captured_request->largePoints, available.largePoints);\r\n  ReportMismatchedFeature(captured_request->alphaToOne, av"
  "ailable.alphaToOne);\r\n  ReportMismatchedFeature(captured_request->multiViewport,\r\n                          available"
  ".multiViewport);\r\n  ReportMismatchedFeature(captured_request->samplerAnisotropy,\r\n                          available"
  ".samplerAnisotropy);\r\n  ReportMismatchedFeature(captured_request->textureCompressionETC2,\r\n                          "
  "available.textureCompressionETC2);\r\n  ReportMismatchedFeature(captured_request->textureCompressionASTC_LDR,\r\n        "
  "                  available.textureCompressionASTC_LDR);\r\n  ReportMismatchedFeature(captured_request->textureCompressio"
  "nBC,\r\n                          available.textureCompressionBC);\r\n  ReportMismatchedFeature(captured_request->occlusi"
  "onQueryPrecise,\r\n                          available.occlusionQueryPrecise);\r\n  ReportMismatchedFeature(captured_requ"
  "est->pipelineStatisticsQuery,\r\n                          available.pipelineStatisticsQuery);\r\n  ReportMismatchedFeatu"
  "re(captured_request->vertexPipelineStoresAndAtomics,\r\n                          available.vertexPipelineStoresAndAtomic"
  "s);\r\n  ReportMismatchedFeature(captured_request->fragmentStoresAndAtomics,\r\n                          available.fragm"
  "entStoresAndAtomics);\r\n  ReportMismatchedFeature(\r\n      captured_request->shaderTessellationAndGeometryPointSize,\r\n"
  "      available.shaderTessellationAndGeometryPointSize);\r\n  ReportMismatchedFeature(captured_request->shaderImageGather"
  "Extended,\r\n                          available.shaderImageGatherExtended);\r\n  ReportMismatchedFeature(captured_reques"
  "t->shaderStorageImageExtendedFormats,\r\n                          available.shaderStorageImageExtendedFormats);\r\n  Rep"
  "ortMismatchedFeature(captured_request->shaderStorageImageMultisample,\r\n                          available.shaderStorag"
  "eImageMultisample);\r\n  ReportMismatchedFeature(captured_request->shaderStorageImageReadWithoutFormat,\r\n              "
  "            available.shaderStorageImageReadWithoutFormat);\r\n  ReportMismatchedFeature(\r\n      captured_request->shad"
  "erStorageImageWriteWithoutFormat,\r\n      available.shaderStorageImageWriteWithoutFormat);\r\n  ReportMismatchedFeature("
  "\r\n      captured_request->shaderUniformBufferArrayDynamicIndexing,\r\n      available.shaderUniformBufferArrayDynamicIn"
  "dexing);\r\n  ReportMismatchedFeature(\r\n      captured_request->shaderSampledImageArrayDynamicIndexing,\r\n      availa"
  "ble.shaderSampledImageArrayDynamicIndexing);\r\n  ReportMismatchedFeature(\r\n      captured_request->shaderStorageBuffer"
  "ArrayDynamicIndexing,\r\n      available.shaderStorageBufferArrayDynamicIndexing);\r\n  ReportMismatchedFeature(\r\n     "
  " captured_request->shaderStorageImageArrayDynamicIndexing,\r\n      available.shaderStorageImageArrayDynamicIndexing);\r\n"
  "  ReportMismatchedFeature(captured_request->shaderClipDistance,\r\n                          available.shaderClipDistance"
  ");\r\n  ReportMismatchedFeature(captured_request->shaderCullDistance,\r\n                          available.shaderCullDi"
  "stance);\r\n  ReportMismatchedFeature(captured_request->shaderFloat64,\r\n                          available.shaderFloat"
  "64);\r\n  ReportMismatchedFeature(captured_request->shaderInt64, available.shaderInt64);\r\n  ReportMismatchedFeature(cap"
  "tured_request->shaderInt16, available.shaderInt16);\r\n  ReportMismatchedFeature(captured_request->shaderResourceResidenc"
  "y,\r\n                          available.shaderResourceResidency);\r\n  ReportMismatchedFeature(captured_request->shader"
  "ResourceMinLod,\r\n                          available.shaderResourceMinLod);\r\n  ReportMismatchedFeature(captured_reque"
  "st->sparseBinding,\r\n                          available.sparseBinding);\r\n  ReportMismatchedFeature(captured_request->"
  "sparseResidencyBuffer,\r\n                          available.sparseResidencyBuffer);\r\n  ReportMismatchedFeature(captur"
  "ed_request->sparseResidencyImage2D,\r\n                          available.sparseResidencyImage2D);\r\n  ReportMismatched"
  "Feature(captured_request->sparseResidencyImage3D,\r\n                          available.sparseResidencyImage3D);\r\n  Re"
  "portMismatchedFeature(captured_request->sparseResidency2Samples,\r\n                          available.sparseResidency2S"
  "amples);\r\n  ReportMismatchedFeature(captured_request->sparseResidency4Samples,\r\n                          available.s"
  "parseResidency4Samples);\r\n  ReportMismatchedFeature(captured_request->sparseResidency8Samples,\r\n                     "
  "     available.sparseResidency8Samples);\r\n  ReportMismatchedFeature(captured_request->sparseResidency16Samples,\r\n    "
  "                      available.sparseResidency16Samples);\r\n  ReportMismatchedFeature(captured_request->sparseResidency"
  "Aliased,\r\n                          available.sparseResidencyAliased);\r\n  ReportMismatchedFeature(captured_request->v"
  "ariableMultisampleRate,\r\n                          available.variableMultisampleRate);\r\n  ReportMismatchedFeature(cap"
  "tured_request->inheritedQueries,\r\n                          available.inheritedQueries);\r\n}\r\n\r\nbool RegionsOverla"
  "p(const Region &r1, const Region &r2) {\r\n  // interval '1' and '2' start and end points:\r\n  uint64_t i1_start = r1.of"
  "fset;\r\n  uint64_t i1_end = r1.offset + r1.size;\r\n  uint64_t i2_start = r2.offset;\r\n  uint64_t i2_end = r2.offset + "
  "r2.size;\r\n\r\n  // two intervals i1 [s, e] and i2 [s, e] intersect\r\n  // if X = max(i1.s, i2.s) < Y = min(i1.e, i2.e)"
  ".\r\n  return std::max<uint64_t>(i1_start, i2_start) <\r\n         std::min<uint64_t>(i1_end, i2_end);\r\n}\r\n\r\n// Reg"
  "ionsIntersect(A, B) == RegionsIntersect(B, A)\r\nRegion RegionsIntersect(const Region &r1, const Region &r2) {\r\n  Regio"
  "n r;\r\n\r\n  // two intervals i1 [s, e] and i2 [s, e] intersect\r\n  // if X = max(i1.s, i2.s) < Y = min(i1.e, i2.e).\r\n"
  "  r.offset = std::max<uint64_t>(r1.offset, r2.offset);\r\n  r.size =\r\n      std::min<uint64_t>(r1.offset + r1.size, r2."
  "offset + r2.size) - r.offset;\r\n  return r;\r\n}\r\n\r\nvoid MapUpdate(const AuxVkTraceResources &aux, uint8_t *dst, uin"
  "t8_t *src,\r\n               VkMappedMemoryRange range, VkMemoryAllocateInfo &ai,\r\n               MemoryRemapVec &remap"
  ", VkDevice dev) {\r\n  if (dst != NULL) {\r\n    range.size =\r\n        std::min<uint64_t>(ai.allocationSize - range.off"
  "set, range.size);\r\n    std::vector<VkMappedMemoryRange> ranges;\r\n    Region memory_region = {range.offset, range.size"
  "};\r\n    // CHECK(range.size != VK_WHOLE_SIZE);\r\n\r\n    if (remap.size() > 0) {\r\n      for (uint32_t i = 0; i < rem"
  "ap.size(); i++) {\r\n        MemoryRemap mr = remap[i];\r\n        Region captured_resource_region(mr.capture.offset, mr."
  "capture.size);\r\n        // If this memory range doesn't overlap with any captured resource\r\n        // continue\r\n  "
  "      if (!RegionsOverlap(memory_region, captured_resource_region)) continue;\r\n\r\n        // Find the inteval where th"
  "ese two regions overlap. It is guaranteed to\r\n        // be non-null.\r\n        Region intersect =\r\n            Regi"
  "onsIntersect(memory_region, captured_resource_region);\r\n\r\n        uint64_t skipped_resource_bytes = intersect.offset "
  "- mr.capture.offset;\r\n        uint64_t skipped_memory_bytes = intersect.offset - memory_region.offset;\r\n        inter"
  "sect.size = std::min<uint64_t>(intersect.size, mr.replay.size);\r\n\r\n        memcpy(dst + mr.replay.offset + skipped_re"
  "source_bytes,\r\n               src + skipped_memory_bytes, intersect.size);\r\n\r\n        VkMappedMemoryRange r = range"
  ";\r\n        r.offset = mr.replay.offset + skipped_resource_bytes;\r\n        r.size =\r\n            AlignedSize(r.offse"
  "t + intersect.size,\r\n                        aux.physDeviceProperties.limits.nonCoherentAtomSize);\r\n        r.offset "
  "= AlignedDown(\r\n            r.offset, aux.physDeviceProperties.limits.nonCoherentAtomSize);\r\n        r.size = r.size "
  "- r.offset;\r\n        if (r.offset + r.size > range.offset + range.size ||\r\n            r.offset + r.size > ai.allocat"
  "ionSize) {\r\n          r.size = VK_WHOLE_SIZE;\r\n        }\r\n        ranges.push_back(r);\r\n      }\r\n    } else {\r"
  "\n      memcpy(dst + range.offset, src, range.size);\r\n      ranges.push_back(range);\r\n    }\r\n\r\n    CHECK_VK_SUCCE"
  "SS(\r\n        vkFlushMappedMemoryRanges(dev, (uint32_t)ranges.size(), ranges.data()));\r\n  }\r\n}\r\n\r\nbool IsExtEnab"
  "led(const char *const *extList, uint32_t count, const char *ext) {\r\n  for (uint32_t i = 0; i < count; i++) {\r\n    if "
  "(strcmp(extList[i], ext) == 0) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nbool IsExtSupported(VkPhysicalDevice ph"
  "ysicalDevice, const char *ext) {\r\n  uint32_t extensionCount;\r\n  vkEnumerateDeviceExtensionProperties(physicalDevice, "
  "NULL, &extensionCount,\r\n                                       NULL);\r\n  std::vector<VkExtensionProperties> extension"
  "s(extensionCount);\r\n  vkEnumerateDeviceExtensionProperties(physicalDevice, NULL, &extensionCount,\r\n                  "
  "                     extensions.data());\r\n  for (auto extension : extensions) {\r\n    if (strcmp(extension.extensionNa"
  "me, ext) == 0) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nstd::string StageProgressString(con"
  "st char *stage, uint32_t i, uint32_t N) {\r\n  return std::string(\"RenderDoc Frame Loop: \" + std::string(stage) + \" pa"
  "rt \" +\r\n                     std::to_string(i) + \" of \" + std::to_string(N));\r\n}\r\n\r\nstd::string GetEnvString(c"
  "onst char *envVarName) {\r\n  std::string val;\r\n#ifdef _WIN32\r\n  char *buf = NULL;\r\n  if (_dupenv_s(&buf, NULL, env"
  "VarName) == 0 && buf) {\r\n    val = buf;\r\n    free(buf);\r\n  }\r\n#else\r\n  char *p = getenv(envVarName);\r\n  if (p"
  ") {\r\n    val = p;\r\n  }\r\n#endif\r\n  return val;\r\n}\r\n\r\nint GetEnvInt(const char *envVarName, int defVal) {\r\n"
  "  std::string val = GetEnvString(envVarName);\r\n  return val.empty() ? defVal : atoi(val.c_str());\r\n}\r\n\r\nFILE *Ope"
  "nFile(char const *fileName, char const *mode) {\r\n  FILE *fp = NULL;\r\n#ifdef _WIN32\r\n  if (fopen_s(&fp, fileName, mo"
  "de) != 0) fp = NULL;\r\n#else\r\n  fp = fopen(fileName, mode);\r\n#endif\r\n  return fp;\r\n}\r\n\r\nvoid AddResourceName"
  "(ResourceNamesMap &map, uint64_t handle, const char *type,\r\n                     const char *name) {\r\n  VkHandle h = "
  "VkHandle(handle, type);\r\n  if (map.find(h) != map.end()) {\r\n    // Vulkan objects of a non-dispatchable type may have"
  " the same handle value,\r\n    // Concatenate the names in this case.\r\n    std::string newName = map[h] + \"_\" + std::"
  "string(name);\r\n    map[h] = newName;\r\n  } else {\r\n    map[h] = std::string(name);\r\n  }\r\n}\r\n\r\nconst char *Ge"
  "tResourceName(const ResourceNamesMap &map, VkHandle handle) {\r\n  auto p = map.find(handle);\r\n  CHECK(p != map.end()) "
  "<< \"Cannot get resource name with type \" << handle.type\r\n                        << \" and value \" << handle.handle;"
  "\r\n  return p->second.c_str();\r\n}\r\n\r\nbool DirExist(const std::string &path) {\r\n  struct stat info;\r\n  if (stat"
  "(path.c_str(), &info) != 0) {\r\n    return false;\r\n  }\r\n  return (info.st_mode & S_IFDIR) != 0;\r\n}\r\n\r\nstd::str"
  "ing NormalizePath(std::string path) {\r\n#if defined(_WIN32)\r\n  // Replace slash with backslash and add trailing slash "
  "if needed.\r\n  // Trailing slash is for concatenating file name to directory later.\r\n  std::replace(path.begin(), path"
  ".end(), '/', '\\\\');\r\n  if (!path.empty() && path.back() != '\\\\') {\r\n    path.push_back('\\\\');\r\n  }\r\n#else\r"
  "\n  // Add trailing slash if needed.\r\n  // Trailing slash is for concatenating file name to directory later.\r\n  if (!"
  "path.empty() && path.back() != '/') {\r\n    path.push_back('/');\r\n  }\r\n#endif\r\n  return path;\r\n}\r\n\r\nbool Cre"
  "ateDir(const std::string &path) {\r\n#if defined(_WIN32)\r\n  int nError = _mkdir(path.c_str());\r\n#else\r\n  mode_t nMo"
  "de = 0755;\r\n  int nError = mkdir(path.c_str(), nMode);\r\n#endif\r\n  if (nError == 0) return true;\r\n\r\n  switch (er"
  "rno) {\r\n    case ENOENT:  // something along the path does not exist\r\n    {\r\n#if defined(_WIN32)\r\n      size_t po"
  "s = path.find_last_of('\\\\');\r\n#else\r\n      size_t pos = path.find_last_of('/');\r\n#endif\r\n      if (pos == std::"
  "string::npos) return false;\r\n      if (!CreateDir(path.substr(0, pos))) return false;\r\n#if defined(_WIN32)\r\n      r"
  "eturn (_mkdir(path.c_str()) == 0 || DirExist(path));\r\n#else\r\n      return (mkdir(path.c_str(), nMode) == 0 || DirExis"
  "t(path));\r\n#endif\r\n    }\r\n    case EEXIST:\r\n      return DirExist(path);\r\n    default:\r\n      return false;\r"
  "\n  }\r\n}\r\n\r\nbool SetOutputFileName(const char *fileName, std::string *outputFileName) {\r\n  if (strlen(fileName) ="
  "= 0) return false;\r\n  *outputFileName = fileName;\r\n  return true;\r\n}\r\n\r\nbool SetOutputDir(const char *path, std"
  "::string *outputDir) {\r\n  std::string dirPath = NormalizePath(path);\r\n  if (DirExist(dirPath) || CreateDir(dirPath)) "
  "{\r\n    *outputDir = dirPath;\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nbool ParseDirCom"
  "mandLineFlag(int argc, char **argv, int *i,\r\n                             std::string *outputDir) {\r\n  if (strcmp(arg"
  "v[*i], \"-d\") == 0 || strcmp(argv[*i], \"--dir\") == 0) {\r\n    *i = *i + 1;\r\n    if (*i >= argc) {\r\n      return f"
  "alse;\r\n    }\r\n    if (SetOutputDir(argv[*i], outputDir)) {\r\n      *i = *i + 1;\r\n      return true;\r\n    }\r\n  "
  "}\r\n  return false;\r\n}\r\n\r\nbool ParseFileCommandLineFlag(int argc, char **argv, int *i,\r\n                        "
  "      std::string *outputFileName) {\r\n  if (strcmp(argv[*i], \"-f\") == 0 || strcmp(argv[*i], \"--file\") == 0) {\r\n  "
  "  *i = *i + 1;\r\n    if (*i >= argc) {\r\n      return false;\r\n    }\r\n    if (SetOutputFileName(argv[*i], outputFile"
  "Name)) {\r\n      *i = *i + 1;\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n";
const char fileData_15[] =
  "/******************************************************************************\r\n * The MIT License (MIT)\r\n *\r\n * C"
  "opyright (c) 2018 Google LLC\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n"
  " * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restrict"
  "ion, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or s"
  "ell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the "
  "following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all co"
  "pies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIN"
  "D, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICUL"
  "AR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES"
  " OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTI"
  "ON WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n ********************************************"
  "**********************************/\r\n#pragma once\r\n\r\n#include <assert.h>\r\n#include <inttypes.h>\r\n#include <math"
  ".h>\r\n#include <memory.h>\r\n#include <stdio.h>\r\n#if defined(_WIN32)\r\n#include <Windows.h>\r\n#endif\r\n\r\n#include"
  " <algorithm>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <vector>\r\n\r\n#include \"vulkan/vulkan.h\"\r\n\r\n"
  "#include \"format_helper.h\"\r\n\r\n#define STRINGIFY(s) #s\r\n\r\nclass CheckStream {\r\n public:\r\n  CheckStream(const"
  " char *file, int line, const char *condition);\r\n  ~CheckStream();\r\n\r\n  std::ostream &stream() { return m_stream; }\r"
  "\n\r\n private:\r\n  std::ostringstream m_stream;\r\n};\r\n\r\nstruct StreamToVoid {\r\n  // Use an operator with lower p"
  "recedence than operator<<() to implicitly\r\n  // coerce ostream into void.\r\n  void operator&(std::ostream &) {}\r\n};\r"
  "\n\r\n#define CHECK(condition) \\\r\n  (condition)            \\\r\n      ? (void)0          \\\r\n      : StreamToVoid()"
  " & \\\r\n            CheckStream(__FILE__, __LINE__, STRINGIFY(condition)).stream()\r\n\r\n#define CHECK_VK_SUCCESS(resul"
  "t)                                               \\\r\n  {                                                               "
  "             \\\r\n    VkResult r = result;                                                       \\\r\n    r == VK_SUCCE"
  "SS                                                            \\\r\n        ? (void)0                                    "
  "                          \\\r\n        : StreamToVoid() &                                                     \\\r\n    "
  "          CheckStream(__FILE__, __LINE__, STRINGIFY(result == VK_SUCCESS)) \\\r\n                      .stream()         "
  "                                       \\\r\n                  << \"VkResult is \\\"\" << VkResultToString(r) << \"\\\"\""
  ";          \\\r\n  }\r\n\r\nstruct VkHandle {\r\n  uint64_t handle;\r\n  std::string type;\r\n  VkHandle(uint64_t h, cons"
  "t char *t) : handle(h), type(t) {}\r\n  bool operator<(const VkHandle &rhs) const {\r\n    if (handle < rhs.handle)\r\n  "
  "    return true;\r\n    else if (handle > rhs.handle)\r\n      return false;\r\n    else\r\n      return (type < rhs.type"
  ");\r\n  }\r\n};\r\n\r\ntypedef std::map<VkHandle, std::string> ResourceNamesMap;\r\n\r\nvoid AddResourceName(ResourceName"
  "sMap &map, uint64_t handle, const char *type,\r\n                     const char *name);\r\nconst char *GetResourceName(c"
  "onst ResourceNamesMap &map, VkHandle handle);\r\n\r\nstruct AuxVkTraceResources {\r\n  VkInstance instance;\r\n  VkDevice"
  " device;\r\n  VkPhysicalDevice physDevice;\r\n  VkPhysicalDeviceProperties physDeviceProperties;\r\n  VkPhysicalDeviceMem"
  "oryProperties physDeviceMemoryProperties;\r\n  std::vector<VkQueueFamilyProperties> queueFamilyProperties;\r\n  VkDebugRe"
  "portCallbackEXT callback;\r\n  VkDebugUtilsMessengerEXT messenger;\r\n  VkCommandPool command_pool;\r\n  VkCommandBuffer "
  "command_buffer;\r\n  VkQueue queue;\r\n  VkFence fence;\r\n  VkSemaphore acquire_semaphore, present_semaphore;\r\n#ifdef "
  "_WIN32\r\n  HINSTANCE hInstance;\r\n  HWND hWnd;\r\n#endif\r\n  VkSurfaceKHR surface;\r\n  VkSwapchainKHR swapchain;\r\n "
  " VkImageCreateInfo virtualSwapchainImageCreateInfo;\r\n  std::vector<VkImage> virtualSwapchainImages;\r\n  std::vector<Vk"
  "Image> realSwapchainImages;\r\n  std::vector<VkDeviceMemory> virtualSwapchainImageMemories;\r\n\r\n  uint64_t getTimestam"
  "pValidBits(VkQueue queue) {\r\n    uint64_t bits = 0;\r\n    if (!physDeviceProperties.limits.timestampComputeAndGraphics"
  ") return 0;\r\n    for (uint32_t i = 0; i < queueFamilyProperties.size() && bits == 0; i++) {\r\n      if ((queueFamilyPr"
  "operties[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) == 0 &&\r\n          (queueFamilyProperties[i].queueFlags & VK_QUEUE_COMP"
  "UTE_BIT) == 0)\r\n        continue;\r\n      for (uint32_t j = 0; j < queueFamilyProperties[i].queueCount && bits == 0;\r"
  "\n           j++) {\r\n        VkQueue q = NULL;\r\n        vkGetDeviceQueue(device, i, j, &q);\r\n        if (q == queue"
  ") {\r\n          bits =\r\n              (queueFamilyProperties[i].timestampValidBits == 64)\r\n                  ? UINT6"
  "4_MAX\r\n                  : (1ULL << queueFamilyProperties[i].timestampValidBits) - 1;\r\n        }\r\n      }\r\n    }\r"
  "\n    return bits;\r\n  }\r\n\r\n  int32_t queueBits(VkQueue queue, bool &isGraphics, bool &isCompute,\r\n               "
  "     bool &isTransfer) {\r\n    for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) {\r\n      for (uint32_t j = "
  "0; j < queueFamilyProperties[i].queueCount; j++) {\r\n        VkQueue q = NULL;\r\n        vkGetDeviceQueue(device, i, j,"
  " &q);\r\n        if (q == queue) {\r\n          isGraphics =\r\n              queueFamilyProperties[i].queueFlags & VK_QU"
  "EUE_GRAPHICS_BIT;\r\n          isCompute =\r\n              (queueFamilyProperties[i].queueFlags & VK_QUEUE_COMPUTE_BIT) "
  "&&\r\n              !isGraphics;\r\n          isTransfer =\r\n              (queueFamilyProperties[i].queueFlags & VK_QUE"
  "UE_TRANSFER_BIT) &&\r\n              !isGraphics && !isCompute;\r\n          return i;\r\n        }\r\n      }\r\n    }\r"
  "\n    // this should be unreachable code for any valid queue.\r\n    assert(0);\r\n    return -1;\r\n  }\r\n\r\n  bool is"
  "GraphicsQueue(VkQueue queue) {\r\n    bool isGraphics, isCompute, isTransfer;\r\n    if (queueBits(queue, isGraphics, isC"
  "ompute, isTransfer) >= 0)\r\n      return isGraphics;\r\n    else\r\n      return false;\r\n  }\r\n  bool isComputeQueue("
  "VkQueue queue) {\r\n    bool isGraphics, isCompute, isTransfer;\r\n    if (queueBits(queue, isGraphics, isCompute, isTran"
  "sfer) >= 0)\r\n      return isCompute;\r\n    else\r\n      return false;\r\n  }\r\n};\r\n\r\nVkResult CreateSurface(AuxV"
  "kTraceResources &aux);\r\nVkResult CreateVirtualSwapchainImages(\r\n    AuxVkTraceResources &aux, const VkSwapchainCreate"
  "InfoKHR &swapchainInfo,\r\n    VkImage *images, uint32_t imageCount);\r\n\r\nVkResult AcquireVirtualSwapchainImage(AuxVkT"
  "raceResources &aux, VkImage image);\r\n\r\nVkResult PresentVirtualSwapchainImage(AuxVkTraceResources &aux, VkImage image)"
  ";\r\n\r\nstruct Region {\r\n  uint64_t offset = 0;\r\n  uint64_t size = 0;\r\n  Region(){};\r\n  Region(uint64_t o, uint6"
  "4_t s) : offset(o), size(s) {}\r\n};\r\n\r\nstruct MemoryRemap {\r\n  Region capture;\r\n  Region replay;\r\n};\r\n\r\nty"
  "pedef std::vector<MemoryRemap> MemoryRemapVec;\r\n\r\nVkResult vkDebugMarkerSetObject(VkDevice device,\r\n               "
  "                 const VkDebugMarkerObjectTagInfoEXT *pTagInfo);\r\nVkResult vkDebugMarkerSetObjectName(\r\n    VkDevice "
  "device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo);\r\nvoid vkCmdDebugMarkerBegin(VkCommandBuffer commandBuffer,\r\n"
  "                           const VkDebugMarkerMarkerInfoEXT *pMarker);\r\nvoid vkCmdDebugMarkerEnd(VkCommandBuffer comman"
  "dBuffer);\r\nvoid vkCmdDebugMarkerInsert(VkCommandBuffer commandBuffer,\r\n                            const VkDebugMarke"
  "rMarkerInfoEXT *pMarkerInfo);\r\n\r\nvoid vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,\r\n     "
  "                       VkDeviceSize offset, VkBuffer countBuffer,\r\n                            VkDeviceSize countBuffer"
  "Offset,\r\n                            uint32_t maxDrawCount, uint32_t stride);\r\n\r\nvoid vkCmdDrawIndexedIndirectCount"
  "(VkCommandBuffer commandBuffer,\r\n                                   VkBuffer buffer, VkDeviceSize offset,\r\n          "
  "                         VkBuffer countBuffer,\r\n                                   VkDeviceSize countBufferOffset,\r\n "
  "                                  uint32_t maxDrawCount, uint32_t stride);\r\n\r\nVkPresentModeKHR GetCompatiblePresentMo"
  "de(\r\n    VkPresentModeKHR captured, std::vector<VkPresentModeKHR> present);\r\n\r\nint32_t MemoryTypeIndex(VkMemoryProp"
  "ertyFlags mask, uint32_t bits,\r\n                        const VkPhysicalDeviceMemoryProperties &memory_props);\r\n\r\nu"
  "int32_t CompatibleMemoryTypeIndex(\r\n    uint32_t type, const VkPhysicalDeviceMemoryProperties &captured,\r\n    const V"
  "kPhysicalDeviceMemoryProperties &present, uint32_t bits);\r\n\r\nVkResult CheckMemoryAllocationCompatibility(\r\n    uint"
  "32_t type, const VkPhysicalDeviceMemoryProperties &captured,\r\n    const VkPhysicalDeviceMemoryProperties &present,\r\n "
  "   const VkMemoryRequirements &requirements);\r\n\r\nvoid ReadBuffer(const char *name, std::vector<uint8_t> &buf);\r\n\r\n"
  "void InitializeDestinationBuffer(VkDevice device, VkBuffer *dst_buffer,\r\n                                 VkDeviceMemor"
  "y dst_memory, uint64_t size);\r\nvoid InitializeSourceBuffer(VkDevice device, VkBuffer *buffer,\r\n                      "
  "      VkDeviceMemory *memory, size_t size,\r\n                            uint8_t *initial_data,\r\n                     "
  "       VkPhysicalDeviceMemoryProperties props,\r\n                            MemoryRemapVec &remap);\r\nvoid InitializeA"
  "uxResources(AuxVkTraceResources *aux, VkInstance instance,\r\n                            VkPhysicalDevice physDevice, Vk"
  "Device device);\r\n\r\nvoid ImageLayoutTransition(VkCommandBuffer cmdBuffer, VkImage dstImage,\r\n                       "
  "    VkImageSubresourceRange subresourceRange,\r\n                           VkImageLayout newLayout, uint32_t dstQueueFam"
  "ily,\r\n                           VkImageLayout oldLayout, uint32_t srcQueueFamily);\r\n\r\nvoid ImageLayoutTransition(\r"
  "\n    const AuxVkTraceResources &aux, VkImage dst, VkImageCreateInfo dst_ci,\r\n    VkImageLayout final_layout,\r\n    Vk"
  "ImageLayout old_layout = VK_IMAGE_LAYOUT_UNDEFINED);\r\nvoid ImageLayoutTransition(\r\n    const AuxVkTraceResources &aux"
  ", VkImage dst,\r\n    VkImageSubresourceRange subresourceRange, VkImageLayout final_layout,\r\n    VkImageLayout old_layo"
  "ut = VK_IMAGE_LAYOUT_UNDEFINED);\r\nvoid ImageLayoutTransition(const AuxVkTraceResources &aux, VkImage dstImg,\r\n       "
  "                    uint32_t arrayLayer, uint32_t mipLevel,\r\n                           VkImageAspectFlagBits aspect,\r"
  "\n                           VkImageLayout newLayout, VkImageLayout oldLayout);\r\n\r\nvoid CopyResetImage(const AuxVkTra"
  "ceResources &aux, VkImage dst, VkBuffer src,\r\n                    VkImageCreateInfo dst_ci);\r\nvoid CopyResetBuffer(co"
  "nst AuxVkTraceResources &aux, VkBuffer dst, VkBuffer src,\r\n                     VkDeviceSize size);\r\n\r\nvoid CopyIma"
  "geToBuffer(const AuxVkTraceResources &aux, VkImage src,\r\n                       VkBuffer dst, VkImageCreateInfo src_ci)"
  ";\r\nvoid DiffDeviceMemory(const AuxVkTraceResources &aux, VkDeviceMemory expected,\r\n                      VkDeviceSize"
  " expected_offset, VkDeviceMemory actual,\r\n                      VkDeviceSize actual_offset, VkDeviceSize size,\r\n     "
  "                 const char *name);\r\nvoid InitializeDiffBuffer(VkDevice device, VkBuffer *buffer,\r\n                  "
  "        VkDeviceMemory *memory, size_t size,\r\n                          VkPhysicalDeviceMemoryProperties props);\r\n\r\n"
  "void MakePhysicalDeviceFeaturesMatch(\r\n    const VkPhysicalDeviceFeatures &available,\r\n    VkPhysicalDeviceFeatures *"
  "captured_request);\r\n\r\nvoid RegisterDebugCallback(\r\n    AuxVkTraceResources *aux, VkInstance instance, VkDebugReport"
  "FlagsEXT flags,\r\n    VkDebugReportCallbackEXT *pCallback,\r\n    PFN_vkDebugReportCallbackEXT pfnCallback = VK_NULL_HAN"
  "DLE);\r\n\r\nVkDebugUtilsMessengerCreateInfoEXT DebugUtilsMessengerCreateInfo(\r\n    VkDebugUtilsMessageSeverityFlagsEXT"
  " severity,\r\n    VkDebugUtilsMessageTypeFlagsEXT type,\r\n    PFN_vkDebugUtilsMessengerCallbackEXT pfnCallback = NULL);\r"
  "\n\r\nvoid RegisterDebugUtilsCallback(\r\n    AuxVkTraceResources *aux, VkInstance instance,\r\n    VkDebugUtilsMessageSe"
  "verityFlagsEXT severity,\r\n    VkDebugUtilsMessageTypeFlagsEXT type, VkDebugUtilsMessengerEXT *pMessenger,\r\n    PFN_vk"
  "DebugUtilsMessengerCallbackEXT pfnCallBack = NULL);\r\n\r\nvoid MapUpdate(const AuxVkTraceResources &aux, uint8_t *dst, u"
  "int8_t *src,\r\n               VkMappedMemoryRange range, VkMemoryAllocateInfo &ai,\r\n               MemoryRemapVec &rem"
  "ap, VkDevice dev);\r\n\r\ninline uint64_t AlignedSize(uint64_t size, uint64_t alignment) {\r\n  return ((size / alignment"
  ") + ((size % alignment) > 0 ? 1 : 0)) * alignment;\r\n}\r\n\r\ninline uint64_t AlignedDown(uint64_t size, uint64_t alignm"
  "ent) {\r\n  return (uint64_t(size / alignment)) * alignment;\r\n}\r\n\r\ninline std::string VkResultToString(VkResult r) "
  "{\r\n  switch (r) {\r\n#define RETURN_VK_RESULT_STRING(r) \\\r\n  case VK_##r:                     \\\r\n    return #r\r\n"
  "    RETURN_VK_RESULT_STRING(SUCCESS);\r\n    RETURN_VK_RESULT_STRING(NOT_READY);\r\n    RETURN_VK_RESULT_STRING(TIMEOUT);"
  "\r\n    RETURN_VK_RESULT_STRING(EVENT_SET);\r\n    RETURN_VK_RESULT_STRING(EVENT_RESET);\r\n    RETURN_VK_RESULT_STRING(I"
  "NCOMPLETE);\r\n    RETURN_VK_RESULT_STRING(ERROR_OUT_OF_HOST_MEMORY);\r\n    RETURN_VK_RESULT_STRING(ERROR_OUT_OF_DEVICE_"
  "MEMORY);\r\n    RETURN_VK_RESULT_STRING(ERROR_INITIALIZATION_FAILED);\r\n    RETURN_VK_RESULT_STRING(ERROR_DEVICE_LOST);\r"
  "\n    RETURN_VK_RESULT_STRING(ERROR_MEMORY_MAP_FAILED);\r\n    RETURN_VK_RESULT_STRING(ERROR_LAYER_NOT_PRESENT);\r\n    R"
  "ETURN_VK_RESULT_STRING(ERROR_EXTENSION_NOT_PRESENT);\r\n    RETURN_VK_RESULT_STRING(ERROR_FEATURE_NOT_PRESENT);\r\n    RE"
  "TURN_VK_RESULT_STRING(ERROR_INCOMPATIBLE_DRIVER);\r\n    RETURN_VK_RESULT_STRING(ERROR_TOO_MANY_OBJECTS);\r\n    RETURN_V"
  "K_RESULT_STRING(ERROR_FORMAT_NOT_SUPPORTED);\r\n    RETURN_VK_RESULT_STRING(ERROR_SURFACE_LOST_KHR);\r\n    RETURN_VK_RES"
  "ULT_STRING(ERROR_NATIVE_WINDOW_IN_USE_KHR);\r\n    RETURN_VK_RESULT_STRING(SUBOPTIMAL_KHR);\r\n    RETURN_VK_RESULT_STRIN"
  "G(ERROR_OUT_OF_DATE_KHR);\r\n    RETURN_VK_RESULT_STRING(ERROR_INCOMPATIBLE_DISPLAY_KHR);\r\n    RETURN_VK_RESULT_STRING("
  "ERROR_VALIDATION_FAILED_EXT);\r\n    RETURN_VK_RESULT_STRING(ERROR_INVALID_SHADER_NV);\r\n#undef RETURN_VK_RESULT_STRING\r"
  "\n    default:\r\n      return \"UNKNOWN_ERROR\";\r\n  }\r\n}\r\nbool IsExtEnabled(const char *const *extList, uint32_t c"
  "ount, const char *ext);\r\nbool IsExtSupported(VkPhysicalDevice physicalDevice, const char *ext);\r\n\r\nstd::string Stag"
  "eProgressString(const char *stage, uint32_t i, uint32_t N);\r\n\r\nstd::string GetEnvString(const char *envVarName);\r\ni"
  "nt GetEnvInt(const char *envVarName, int defVal = 0);\r\nFILE *OpenFile(char const *fileName, char const *mode);\r\nstd::"
  "string NormalizePath(std::string path);\r\nbool DirExist(const std::string &path);\r\nbool CreateDir(const std::string &p"
  "ath);\r\nbool SetOutputDir(const char *path, std::string *output);\r\nbool SetOutputFileName(const char *fileName, std::s"
  "tring *output);\r\nbool ParseDirCommandLineFlag(int argc, char **argv, int *i,\r\n                             std::strin"
  "g *outputDir);\r\nbool ParseFileCommandLineFlag(int argc, char **argv, int *i,\r\n                              std::stri"
  "ng *outputFileName);\r\n";
const char fileData_16[] =
  "IF(WIN32)\r\nSET (THIS_PROJECT_NAME sample_cpp_trace)\r\nELSE ()\r\nSET (THIS_PROJECT_NAME sample_cpp_trace_elf)\r\nENDIF"
  " ()\r\n\r\nPROJECT(${THIS_PROJECT_NAME})\r\n\r\nFILE(GLOB HEADERS \"*.h\")\r\nFILE(GLOB SOURCES \"*.cpp\")\r\nSET(SHADERS"
  " )\r\nSET(TEMPLATES main_win.cpp)\r\n\r\nSOURCE_GROUP ( \"Source Files\"   FILES ${SOURCES} )\r\nSOURCE_GROUP ( \"Templat"
  "e Files\" FILES ${TEMPLATES} )\r\nSOURCE_GROUP ( \"Header Files\"   FILES ${HEADERS} )\r\nSOURCE_GROUP ( \"Shader Files\""
  "   FILES ${SHADERS} )\r\n\r\nADD_EXECUTABLE(${THIS_PROJECT_NAME} ${TEMPLATES} ${SOURCES}\r\n                             "
  "       ${HEADERS} ${SHADERS})\r\n\r\nSETUP_PROJECT(${THIS_PROJECT_NAME})\r\n\r\nTARGET_COMPILE_DEFINITIONS(${THIS_PROJECT"
  "_NAME} PRIVATE\r\n                           UNICODE _UNICODE)\r\n\r\nSET(SHIM_DEPS )\r\nIF (ENABLE_SHIM)\r\n  SET(SHIM_D"
  "EPS sample_cpp_shim)\r\nENDIF()\r\n\r\nIF (WIN32)\r\n  TARGET_COMPILE_DEFINITIONS(${THIS_PROJECT_NAME} PRIVATE\r\n       "
  "                      VK_USE_PLATFORM_WIN32_KHR\r\n                             _CRT_SECURE_NO_DEPRECATE)\r\n  TARGET_LIN"
  "K_LIBRARIES(${THIS_PROJECT_NAME}\r\n                        vulkan\r\n                        helper\r\n                 "
  "       comctl32\r\n                        rpcrt4\r\n                        winmm\r\n                        advapi32\r\n"
  "                        wsock32\r\n                        Dbghelp\r\n                        ${SHIM_DEPS})\r\n  SET_TARG"
  "ET_PROPERTIES(${THIS_PROJECT_NAME} PROPERTIES\r\n                        LINK_FLAGS_RELEASE \"/SUBSYSTEM:CONSOLE /STACK:6"
  "7108864\"\r\n                        LINK_FLAGS_DEBUG   \"/SUBSYSTEM:CONSOLE /STACK:67108864\")\r\nELSE ()\r\n  TARGET_CO"
  "MPILE_DEFINITIONS(${THIS_PROJECT_NAME} PRIVATE\r\n                             VK_USE_PLATFORM_XLIB_KHR\r\n              "
  "               __linux__)\r\n  TARGET_LINK_LIBRARIES(${THIS_PROJECT_NAME}\r\n                        libX11.so\r\n       "
  "                 libdl.so\r\n                        helper\r\n                        vulkan\r\n                        "
  "${SHIM_DEPS})\r\nENDIF ()";
const char fileData_17[] =
  "/******************************************************************************\r\n* The MIT License (MIT)\r\n*\r\n* Copy"
  "right (c) 2018 Google LLC\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of "
  "this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, in"
  "cluding without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*"
  " copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following "
  "conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in\r\n* all copies or subst"
  "antial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r"
  "\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NO"
  "NINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIA"
  "BILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE"
  " OR THE USE OR OTHER DEALINGS IN\r\n* THE SOFTWARE.\r\n******************************************************************"
  "************/\r\n#pragma once\r\n\r\n#include <assert.h>\r\n#include <memory.h>\r\n#include <stdint.h>\r\n#include <stdio"
  ".h>\r\n#include <vulkan/vulkan.h>\r\n\r\n#include <string>\r\n#include <vector>\r\n\r\n#include \"helper/helper.h\"\r\n//"
  " #include \"sample_cpp_shim/shim_vulkan.h\"\r\n\r\nvoid PostStageProgress(const char *stage, uint32_t i, uint32_t N);";
const char fileData_18[] =
  "/******************************************************************************\r\n* The MIT License (MIT)\r\n*\r\n* Copy"
  "right (c) 2018 Google LLC\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of "
  "this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, in"
  "cluding without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*"
  " copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following "
  "conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in\r\n* all copies or subst"
  "antial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r"
  "\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NO"
  "NINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIA"
  "BILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE"
  " OR THE USE OR OTHER DEALINGS IN\r\n* THE SOFTWARE.\r\n******************************************************************"
  "************/\r\n//-----------------------------------------------------------------------------\r\n// Generated with Ren"
  "derDoc CPP Code Generator\r\n//\r\n// File: main_win.cpp\r\n//\r\n//-----------------------------------------------------"
  "------------------------\r\n// Defines the entry point that initializes and runs the serialized frame\r\n// capture on Wi"
  "ndows\r\n#if _WIN32\r\n\r\n#include <Windows.h>\r\n\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <sstream>\r"
  "\n#include <stdexcept>\r\n\r\n#include \"gen_main.h\"\r\n\r\n//----------------------------------------------------------"
  "-------------------\r\n// Global Variable for Frame Replay\r\n//---------------------------------------------------------"
  "--------------------\r\nint frameLoops = -1;\r\ndouble accumTimeWithReset = 0;\r\ndouble accumTime = 0;\r\ndouble avgTime"
  "WithReset = 0;\r\ndouble avgTime = 0;\r\ndouble avgFPSWithReset = 0;\r\ndouble avgFPS = 0;\r\nuint64_t frames = 0;\r\ndou"
  "ble avgFrameMilliseconds = 0;\r\nLARGE_INTEGER performanceCounterFrequency;\r\nbool automated = false;\r\nbool resourceRe"
  "set = false;\r\n\r\n#define RDOC_WINDOW_CLASS_NAME L\"RenderDoc Frame Loop\"\r\n#define RDOC_WINDOW_TITLE L\"RenderDoc Fr"
  "ame Loop\"\r\n\r\nstatic LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\nBOOL Regist"
  "erWndClass(HINSTANCE hInstance, UINT style);\r\nHWND CreateWnd(HINSTANCE hInstance, HINSTANCE hPrevInstance, uint32_t Pos"
  "X, uint32_t PosY,\r\n               uint32_t Width, uint32_t Height, DWORD Style, DWORD ExtendedStyle);\r\nvoid CreateRes"
  "ources();\r\nvoid ReleaseResources();\r\nvoid Render();\r\n\r\nvoid PostStageProgress(const char *stage, uint32_t i, uint"
  "32_t N)\r\n{\r\n  SetWindowTextA(appHwnd, StageProgressString(stage, i, N).c_str());\r\n}\r\n\r\n//----------------------"
  "-------------------------------------------------------\r\n// MainWndProc\r\n//------------------------------------------"
  "-----------------------------------\r\nstatic LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lP"
  "aram)\r\n{\r\n  switch(uMsg)\r\n  {\r\n    case WM_KEYDOWN:\r\n      if(wParam == VK_ESCAPE)\r\n      {\r\n        PostQu"
  "itMessage(0);\r\n        return 0;\r\n      }\r\n\r\n      break;\r\n    case WM_CLOSE:\r\n      PostQuitMessage(0);\r\n "
  "     return 0;\r\n      break;\r\n  }\r\n\r\n  return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n}\r\n\r\n//----------"
  "-------------------------------------------------------------------\r\n// RegisterWndClass\r\n//-------------------------"
  "----------------------------------------------------\r\nBOOL RegisterWndClass(HINSTANCE hInstance, UINT style)\r\n{\r\n  "
  "// Populate the struct\r\n  WNDCLASS wc;\r\n  wc.style = style;\r\n  wc.lpfnWndProc = (WNDPROC)MainWndProc;\r\n  wc.cbCls"
  "Extra = 0;\r\n  wc.cbWndExtra = 0;\r\n  wc.hInstance = hInstance;\r\n  wc.hIcon = LoadIcon((HINSTANCE)NULL, IDI_APPLICATI"
  "ON);\r\n  wc.hCursor = LoadCursor((HINSTANCE)NULL, IDC_ARROW);\r\n  wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH"
  ");\r\n  wc.lpszMenuName = L\"\";\r\n  wc.lpszClassName = RDOC_WINDOW_CLASS_NAME;\r\n  BOOL ret = RegisterClass(&wc);\r\n "
  " if(!ret && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)\r\n  {\r\n    return TRUE;\r\n  }\r\n\r\n  return ret;\r\n}\r\n"
  "\r\n//-----------------------------------------------------------------------------\r\n// CreateWnd\r\n//----------------"
  "-------------------------------------------------------------\r\nHWND CreateWnd(HINSTANCE hInstance, HINSTANCE hPrevInsta"
  "nce, uint32_t PosX, uint32_t PosY,\r\n               uint32_t Width, uint32_t Height, DWORD Style, DWORD ExtendedStyle)\r"
  "\n{\r\n  // Need to adjust first, to see if it fits the screen.\r\n  RECT WindowRect = {(LONG)PosX, (LONG)PosY, (LONG)(Po"
  "sX + Width), (LONG)(PosY + Height)};\r\n  AdjustWindowRectEx(&WindowRect, Style, NULL, ExtendedStyle);\r\n  Width = Windo"
  "wRect.right - WindowRect.left;\r\n  Height = WindowRect.bottom - WindowRect.top;\r\n\r\n  return CreateWindowEx(ExtendedS"
  "tyle, RDOC_WINDOW_CLASS_NAME, RDOC_WINDOW_TITLE, Style, PosX, PosY,\r\n                        Width, Height, (HWND)NULL,"
  " (HMENU)NULL, hInstance, (LPVOID)NULL);\r\n}\r\n\r\nvoid CreateResources()\r\n{\r\n  RegisterWndClass(appHinstance, CS_HR"
  "EDRAW | CS_VREDRAW);\r\n  // Resolution Width and Height are declared in gen_variables\r\n  appHwnd = CreateWnd(appHinsta"
  "nce, NULL, 0, 0, resolutionWidth, resolutionHeight,\r\n                      WS_BORDER | WS_DLGFRAME | WS_GROUP | WS_OVER"
  "LAPPED | WS_POPUP | WS_SIZEBOX |\r\n                          WS_SYSMENU | WS_TILED | WS_VISIBLE,\r\n                    "
  "  0);\r\n\r\n  SetWindowTextA(appHwnd, \"RenderDoc Frame Loop: Creating Early Resources\");\r\n  main_early_create();\r\n"
  "  SetWindowTextA(appHwnd, \"RenderDoc Frame Loop: Creating Resources\");\r\n  main_create();\r\n  SetWindowTextA(appHwnd,"
  " \"RenderDoc Frame Loop: Initializing Resources\");\r\n  main_init();\r\n}\r\n\r\n//-------------------------------------"
  "----------------------------------------\r\n// ReleaseResources\r\n//----------------------------------------------------"
  "-------------------------\r\nvoid ReleaseResources()\r\n{\r\n  main_release();\r\n}\r\n\r\n//----------------------------"
  "-------------------------------------------------\r\n// GetTimestampMillis\r\n//-----------------------------------------"
  "------------------------------------\r\ndouble GetTimestampMilliseconds()\r\n{\r\n  LARGE_INTEGER counter;\r\n  QueryPerf"
  "ormanceCounter(&counter);\r\n  return 1e3 * ((double)counter.QuadPart) / performanceCounterFrequency.QuadPart;\r\n}\r\n\r"
  "\n//-----------------------------------------------------------------------------\r\n// Render\r\n//---------------------"
  "--------------------------------------------------------\r\nvoid Render()\r\n{\r\n  double ts_pre_reset = GetTimestampMil"
  "liseconds();\r\n  main_reset();\r\n  double ts_start = GetTimestampMilliseconds();\r\n  main_render();\r\n  double ts_end"
  " = GetTimestampMilliseconds();\r\n  double frame_time = ts_end - ts_start;\r\n  double frame_time_with_reset = ts_end - t"
  "s_pre_reset;\r\n\r\n  frames++;\r\n\r\n  accumTimeWithReset += frame_time_with_reset;\r\n  accumTime += frame_time;\r\n  "
  "avgTimeWithReset = accumTimeWithReset / frames;\r\n  avgTime = accumTime / frames;\r\n  avgFPSWithReset = 1000.0 / avgTim"
  "eWithReset;\r\n  avgFPS = 1000.0 / avgTime;\r\n\r\n  if(frames % 1 == 0)\r\n  {\r\n    char str[256];\r\n    sprintf(str,"
  " \"%s Avg Time [%f / %f] Avg FPS [%f /%f]\", \"RenderDoc Frame Loop\", avgTimeWithReset,\r\n            avgTime, avgFPSWi"
  "thReset, avgFPS);\r\n    SetWindowTextA(appHwnd, str);\r\n  }\r\n}\r\n\r\n//---------------------------------------------"
  "--------------------------------\r\n// ProcessMessages\r\n//-------------------------------------------------------------"
  "----------------\r\nstatic void ProcessMessages(bool &quit)\r\n{\r\n  MSG msg;\r\n  if(PeekMessage(&msg, NULL, 0, 0, PM_R"
  "EMOVE))\r\n  {\r\n    if(msg.message == WM_QUIT)\r\n    {\r\n      quit = true;\r\n    }\r\n    else\r\n    {\r\n      Tr"
  "anslateMessage(&msg);\r\n      DispatchMessage(&msg);\r\n    }\r\n  }\r\n}\r\n\r\n//-------------------------------------"
  "----------------------------------------\r\n// ParseCommandLine\r\n//----------------------------------------------------"
  "-------------------------\r\nstatic bool ParseCommandLine()\r\n{\r\n  int i = 1;\r\n  while(i < __argc)\r\n  {\r\n    if("
  "0 == strcmp(__argv[i], \"-repeat\"))\r\n    {\r\n      i += 1;\r\n      if(i >= __argc)\r\n      {\r\n        return fals"
  "e;\r\n      }\r\n      frameLoops = atoi(__argv[i]);\r\n      i += 1;\r\n    }\r\n    else if(0 == strcmp(__argv[i], \"-r"
  "eset\"))\r\n    {\r\n      resourceReset = true;\r\n      i += 1;\r\n    }\r\n    else\r\n    {\r\n      if(!main_parse_c"
  "ommand_line_flags(__argc, __argv, &i))\r\n        return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n//-----"
  "------------------------------------------------------------------------\r\n// Usage\r\n//-------------------------------"
  "----------------------------------------------\r\nstatic void Usage()\r\n{\r\n  const wchar_t *usage =\r\n      L\"Option"
  "s:\\n\"\r\n      L\"-repeat N    -- Number of frames to run\\n\"\r\n      L\"-reset       -- Perform a state reset in bet"
  "ween frames\\n\";\r\n\r\n  MessageBox(NULL, usage, L\"Invalid command line\", MB_ICONEXCLAMATION);\r\n}\r\n\r\n//--------"
  "---------------------------------------------------------------------\r\n// main\r\n//-----------------------------------"
  "------------------------------------------\r\nint main()\r\n{\r\n  bool quit = false;\r\n\r\n  appHinstance = GetModuleHa"
  "ndle(NULL);\r\n\r\n  // Parse the command line arguments\r\n  if(!ParseCommandLine())\r\n  {\r\n    Usage();\r\n    retur"
  "n EXIT_FAILURE;\r\n  }\r\n\r\n  try\r\n  {\r\n    CreateResources();\r\n\r\n    QueryPerformanceFrequency(&performanceCou"
  "nterFrequency);\r\n\r\n    int repeatIteration = 0;\r\n\r\n    while(frameLoops == -1 || repeatIteration < frameLoops)\r\n"
  "    {\r\n      ProcessMessages(quit);\r\n      if(quit || main_should_quit_now())\r\n      {\r\n        break;\r\n      }"
  "\r\n\r\n      Render();\r\n\r\n      repeatIteration = (std::max)(0, repeatIteration + 1);\r\n    }\r\n  }\r\n  catch(std"
  "::exception &e)\r\n  {\r\n    if(automated)\r\n    {\r\n      fprintf(stderr, \"Error: %s\", e.what());\r\n    }\r\n    e"
  "lse\r\n    {\r\n      std::string errorMessage(e.what());\r\n      std::wstring errorMessageW(errorMessage.begin(), error"
  "Message.end());\r\n      MessageBox(NULL, errorMessageW.c_str(), L\"Error\", MB_ICONEXCLAMATION);\r\n    }\r\n  }\r\n\r\n"
  "  ReleaseResources();\r\n  return EXIT_SUCCESS;\r\n}\r\n\r\n#endif    // if _WIN32\r\n";
}    // namespace

rdcarray<ResourceFileDesc> ResourceFiles = {  {R"(templates/CPPTemplates.tmpl)", 8775, fileData_1},
  {R"(templates/VkTemplates.tmpl)", 25141, fileData_2},
  {R"(vulkan/build_vs2015.bat)", 226, fileData_3},
  {R"(vulkan/build_vs2015_ninja.bat)", 446, fileData_4},
  {R"(vulkan/build_vs2017.bat)", 226, fileData_5},
  {R"(vulkan/build_vs2017_ninja.bat)", 475, fileData_6},
  {R"(vulkan/build_vs2019.bat)", 229, fileData_7},
  {R"(vulkan/build_vs2019_ninja.bat)", 475, fileData_8},
  {R"(vulkan/CMakeLists.txt)", 5448, fileData_9},
  {R"(vulkan/Template.user)", 944, fileData_10},
  {R"(vulkan/helper/CMakeLists.txt)", 895, fileData_11},
  {R"(vulkan/helper/format_helper.h)", 2400, fileData_12},
  {R"(vulkan/helper/format_size_and_aspect.cpp)", 40237, fileData_13},
  {R"(vulkan/helper/helper.cpp)", 50882, fileData_14},
  {R"(vulkan/helper/helper.h)", 15350, fileData_15},
  {R"(vulkan/sample_cpp_trace/CMakeLists.txt)", 1951, fileData_16},
  {R"(vulkan/sample_cpp_trace/common.h)", 1608, fileData_17},
  {R"(vulkan/sample_cpp_trace/main_win.cpp)", 10280, fileData_18},
};
}    // namespace vk_cpp_codec
